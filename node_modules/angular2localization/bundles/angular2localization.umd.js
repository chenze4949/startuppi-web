var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/http'), require('@angular/forms')) :
        typeof define === 'function' && define.amd ? define(['exports', '@angular/core', '@angular/http', '@angular/forms'], factory) :
            (factory((global.ng = global.ng || {}, global.ng.angular2localization = global.ng.angular2localization || {}), global.ng.core, global.ng.http, global.ng.forms));
}(this, function (exports, _angular_core, _angular_http, _angular_forms) {
    'use strict';
    var objectTypes = {
        'boolean': false,
        'function': true,
        'object': true,
        'number': false,
        'string': false,
        'undefined': false
    };
    var root = (objectTypes[typeof self] && self) || (objectTypes[typeof window] && window);
    /* tslint:disable:no-unused-variable */
    var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;
    var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;
    var freeGlobal = objectTypes[typeof global] && global;
    if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
        root = freeGlobal;
    }
    var Symbol$1 = root.Symbol;
    var $$observable;
    if (typeof Symbol$1 === 'function') {
        if (Symbol$1.observable) {
            $$observable = Symbol$1.observable;
        }
        else {
            if (typeof Symbol$1.for === 'function') {
                $$observable = Symbol$1.for('observable');
            }
            else {
                $$observable = Symbol$1('observable');
            }
            Symbol$1.observable = $$observable;
        }
    }
    else {
        $$observable = '@@observable';
    }
    function isFunction(x) {
        return typeof x === 'function';
    }
    var isArray = Array.isArray || (function (x) { return x && typeof x.length === 'number'; });
    function isObject(x) {
        return x != null && typeof x === 'object';
    }
    // typeof any so that it we don't have to cast when comparing a result to the error object
    var errorObject = { e: {} };
    var tryCatchTarget;
    function tryCatcher() {
        try {
            return tryCatchTarget.apply(this, arguments);
        }
        catch (e) {
            errorObject.e = e;
            return errorObject;
        }
    }
    function tryCatch(fn) {
        tryCatchTarget = fn;
        return tryCatcher;
    }
    ;
    /**
     * An error thrown when one or more errors have occurred during the
     * `unsubscribe` of a {@link Subscription}.
     */
    var UnsubscriptionError = (function (_super) {
        __extends(UnsubscriptionError, _super);
        function UnsubscriptionError(errors) {
            _super.call(this);
            this.errors = errors;
            this.name = 'UnsubscriptionError';
            this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function (err, i) { return ((i + 1) + ") " + err.toString()); }).join('\n') : '';
        }
        return UnsubscriptionError;
    }(Error));
    /**
     * Represents a disposable resource, such as the execution of an Observable. A
     * Subscription has one important method, `unsubscribe`, that takes no argument
     * and just disposes the resource held by the subscription.
     *
     * Additionally, subscriptions may be grouped together through the `add()`
     * method, which will attach a child Subscription to the current Subscription.
     * When a Subscription is unsubscribed, all its children (and its grandchildren)
     * will be unsubscribed as well.
     *
     * @class Subscription
     */
    var Subscription = (function () {
        /**
         * @param {function(): void} [unsubscribe] A function describing how to
         * perform the disposal of resources when the `unsubscribe` method is called.
         */
        function Subscription(unsubscribe) {
            /**
             * A flag to indicate whether this Subscription has already been unsubscribed.
             * @type {boolean}
             */
            this.isUnsubscribed = false;
            if (unsubscribe) {
                this._unsubscribe = unsubscribe;
            }
        }
        /**
         * Disposes the resources held by the subscription. May, for instance, cancel
         * an ongoing Observable execution or cancel any other type of work that
         * started when the Subscription was created.
         * @return {void}
         */
        Subscription.prototype.unsubscribe = function () {
            var hasErrors = false;
            var errors;
            if (this.isUnsubscribed) {
                return;
            }
            this.isUnsubscribed = true;
            var _a = this, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;
            this._subscriptions = null;
            if (isFunction(_unsubscribe)) {
                var trial = tryCatch(_unsubscribe).call(this);
                if (trial === errorObject) {
                    hasErrors = true;
                    (errors = errors || []).push(errorObject.e);
                }
            }
            if (isArray(_subscriptions)) {
                var index = -1;
                var len = _subscriptions.length;
                while (++index < len) {
                    var sub = _subscriptions[index];
                    if (isObject(sub)) {
                        var trial = tryCatch(sub.unsubscribe).call(sub);
                        if (trial === errorObject) {
                            hasErrors = true;
                            errors = errors || [];
                            var err = errorObject.e;
                            if (err instanceof UnsubscriptionError) {
                                errors = errors.concat(err.errors);
                            }
                            else {
                                errors.push(err);
                            }
                        }
                    }
                }
            }
            if (hasErrors) {
                throw new UnsubscriptionError(errors);
            }
        };
        /**
         * Adds a tear down to be called during the unsubscribe() of this
         * Subscription.
         *
         * If the tear down being added is a subscription that is already
         * unsubscribed, is the same reference `add` is being called on, or is
         * `Subscription.EMPTY`, it will not be added.
         *
         * If this subscription is already in an `isUnsubscribed` state, the passed
         * tear down logic will be executed immediately.
         *
         * @param {TeardownLogic} teardown The additional logic to execute on
         * teardown.
         * @return {Subscription} Returns the Subscription used or created to be
         * added to the inner subscriptions list. This Subscription can be used with
         * `remove()` to remove the passed teardown logic from the inner subscriptions
         * list.
         */
        Subscription.prototype.add = function (teardown) {
            if (!teardown || (teardown === this) || (teardown === Subscription.EMPTY)) {
                return;
            }
            var sub = teardown;
            switch (typeof teardown) {
                case 'function':
                    sub = new Subscription(teardown);
                case 'object':
                    if (sub.isUnsubscribed || typeof sub.unsubscribe !== 'function') {
                        break;
                    }
                    else if (this.isUnsubscribed) {
                        sub.unsubscribe();
                    }
                    else {
                        (this._subscriptions || (this._subscriptions = [])).push(sub);
                    }
                    break;
                default:
                    throw new Error('Unrecognized teardown ' + teardown + ' added to Subscription.');
            }
            return sub;
        };
        /**
         * Removes a Subscription from the internal list of subscriptions that will
         * unsubscribe during the unsubscribe process of this Subscription.
         * @param {Subscription} subscription The subscription to remove.
         * @return {void}
         */
        Subscription.prototype.remove = function (subscription) {
            // HACK: This might be redundant because of the logic in `add()`
            if (subscription == null || (subscription === this) || (subscription === Subscription.EMPTY)) {
                return;
            }
            var subscriptions = this._subscriptions;
            if (subscriptions) {
                var subscriptionIndex = subscriptions.indexOf(subscription);
                if (subscriptionIndex !== -1) {
                    subscriptions.splice(subscriptionIndex, 1);
                }
            }
        };
        return Subscription;
    }());
    Subscription.EMPTY = (function (empty) {
        empty.isUnsubscribed = true;
        return empty;
    }(new Subscription()));
    var Symbol$2 = root.Symbol;
    var $$rxSubscriber = (typeof Symbol$2 === 'function' && typeof Symbol$2.for === 'function') ?
        Symbol$2.for('rxSubscriber') : '@@rxSubscriber';
    var empty = {
        isUnsubscribed: true,
        next: function (value) { },
        error: function (err) { throw err; },
        complete: function () { }
    };
    /**
     * Implements the {@link Observer} interface and extends the
     * {@link Subscription} class. While the {@link Observer} is the public API for
     * consuming the values of an {@link Observable}, all Observers get converted to
     * a Subscriber, in order to provide Subscription-like capabilities such as
     * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for
     * implementing operators, but it is rarely used as a public API.
     *
     * @class Subscriber<T>
     */
    var Subscriber = (function (_super) {
        __extends(Subscriber, _super);
        /**
         * @param {Observer|function(value: T): void} [destinationOrNext] A partially
         * defined Observer or a `next` callback function.
         * @param {function(e: ?any): void} [error] The `error` callback of an
         * Observer.
         * @param {function(): void} [complete] The `complete` callback of an
         * Observer.
         */
        function Subscriber(destinationOrNext, error, complete) {
            _super.call(this);
            this.syncErrorValue = null;
            this.syncErrorThrown = false;
            this.syncErrorThrowable = false;
            this.isStopped = false;
            switch (arguments.length) {
                case 0:
                    this.destination = empty;
                    break;
                case 1:
                    if (!destinationOrNext) {
                        this.destination = empty;
                        break;
                    }
                    if (typeof destinationOrNext === 'object') {
                        if (destinationOrNext instanceof Subscriber) {
                            this.destination = destinationOrNext;
                            this.destination.add(this);
                        }
                        else {
                            this.syncErrorThrowable = true;
                            this.destination = new SafeSubscriber(this, destinationOrNext);
                        }
                        break;
                    }
                default:
                    this.syncErrorThrowable = true;
                    this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);
                    break;
            }
        }
        /**
         * A static factory for a Subscriber, given a (potentially partial) definition
         * of an Observer.
         * @param {function(x: ?T): void} [next] The `next` callback of an Observer.
         * @param {function(e: ?any): void} [error] The `error` callback of an
         * Observer.
         * @param {function(): void} [complete] The `complete` callback of an
         * Observer.
         * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)
         * Observer represented by the given arguments.
         */
        Subscriber.create = function (next, error, complete) {
            var subscriber = new Subscriber(next, error, complete);
            subscriber.syncErrorThrowable = false;
            return subscriber;
        };
        /**
         * The {@link Observer} callback to receive notifications of type `next` from
         * the Observable, with a value. The Observable may call this method 0 or more
         * times.
         * @param {T} [value] The `next` value.
         * @return {void}
         */
        Subscriber.prototype.next = function (value) {
            if (!this.isStopped) {
                this._next(value);
            }
        };
        /**
         * The {@link Observer} callback to receive notifications of type `error` from
         * the Observable, with an attached {@link Error}. Notifies the Observer that
         * the Observable has experienced an error condition.
         * @param {any} [err] The `error` exception.
         * @return {void}
         */
        Subscriber.prototype.error = function (err) {
            if (!this.isStopped) {
                this.isStopped = true;
                this._error(err);
            }
        };
        /**
         * The {@link Observer} callback to receive a valueless notification of type
         * `complete` from the Observable. Notifies the Observer that the Observable
         * has finished sending push-based notifications.
         * @return {void}
         */
        Subscriber.prototype.complete = function () {
            if (!this.isStopped) {
                this.isStopped = true;
                this._complete();
            }
        };
        Subscriber.prototype.unsubscribe = function () {
            if (this.isUnsubscribed) {
                return;
            }
            this.isStopped = true;
            _super.prototype.unsubscribe.call(this);
        };
        Subscriber.prototype._next = function (value) {
            this.destination.next(value);
        };
        Subscriber.prototype._error = function (err) {
            this.destination.error(err);
            this.unsubscribe();
        };
        Subscriber.prototype._complete = function () {
            this.destination.complete();
            this.unsubscribe();
        };
        Subscriber.prototype[$$rxSubscriber] = function () {
            return this;
        };
        return Subscriber;
    }(Subscription));
    /**
     * We need this JSDoc comment for affecting ESDoc.
     * @ignore
     * @extends {Ignored}
     */
    var SafeSubscriber = (function (_super) {
        __extends(SafeSubscriber, _super);
        function SafeSubscriber(_parent, observerOrNext, error, complete) {
            _super.call(this);
            this._parent = _parent;
            var next;
            var context = this;
            if (isFunction(observerOrNext)) {
                next = observerOrNext;
            }
            else if (observerOrNext) {
                context = observerOrNext;
                next = observerOrNext.next;
                error = observerOrNext.error;
                complete = observerOrNext.complete;
                if (isFunction(context.unsubscribe)) {
                    this.add(context.unsubscribe.bind(context));
                }
                context.unsubscribe = this.unsubscribe.bind(this);
            }
            this._context = context;
            this._next = next;
            this._error = error;
            this._complete = complete;
        }
        SafeSubscriber.prototype.next = function (value) {
            if (!this.isStopped && this._next) {
                var _parent = this._parent;
                if (!_parent.syncErrorThrowable) {
                    this.__tryOrUnsub(this._next, value);
                }
                else if (this.__tryOrSetError(_parent, this._next, value)) {
                    this.unsubscribe();
                }
            }
        };
        SafeSubscriber.prototype.error = function (err) {
            if (!this.isStopped) {
                var _parent = this._parent;
                if (this._error) {
                    if (!_parent.syncErrorThrowable) {
                        this.__tryOrUnsub(this._error, err);
                        this.unsubscribe();
                    }
                    else {
                        this.__tryOrSetError(_parent, this._error, err);
                        this.unsubscribe();
                    }
                }
                else if (!_parent.syncErrorThrowable) {
                    this.unsubscribe();
                    throw err;
                }
                else {
                    _parent.syncErrorValue = err;
                    _parent.syncErrorThrown = true;
                    this.unsubscribe();
                }
            }
        };
        SafeSubscriber.prototype.complete = function () {
            if (!this.isStopped) {
                var _parent = this._parent;
                if (this._complete) {
                    if (!_parent.syncErrorThrowable) {
                        this.__tryOrUnsub(this._complete);
                        this.unsubscribe();
                    }
                    else {
                        this.__tryOrSetError(_parent, this._complete);
                        this.unsubscribe();
                    }
                }
                else {
                    this.unsubscribe();
                }
            }
        };
        SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
            try {
                fn.call(this._context, value);
            }
            catch (err) {
                this.unsubscribe();
                throw err;
            }
        };
        SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
            try {
                fn.call(this._context, value);
            }
            catch (err) {
                parent.syncErrorValue = err;
                parent.syncErrorThrown = true;
                return true;
            }
            return false;
        };
        SafeSubscriber.prototype._unsubscribe = function () {
            var _parent = this._parent;
            this._context = null;
            this._parent = null;
            _parent.unsubscribe();
        };
        return SafeSubscriber;
    }(Subscriber));
    function toSubscriber(nextOrObserver, error, complete) {
        if (nextOrObserver && typeof nextOrObserver === 'object') {
            if (nextOrObserver instanceof Subscriber) {
                return nextOrObserver;
            }
            else if (typeof nextOrObserver[$$rxSubscriber] === 'function') {
                return nextOrObserver[$$rxSubscriber]();
            }
        }
        return new Subscriber(nextOrObserver, error, complete);
    }
    /**
     * A representation of any set of values over any amount of time. This the most basic building block
     * of RxJS.
     *
     * @class Observable<T>
     */
    var Observable = (function () {
        /**
         * @constructor
         * @param {Function} subscribe the function that is  called when the Observable is
         * initially subscribed to. This function is given a Subscriber, to which new values
         * can be `next`ed, or an `error` method can be called to raise an error, or
         * `complete` can be called to notify of a successful completion.
         */
        function Observable(subscribe) {
            this._isScalar = false;
            if (subscribe) {
                this._subscribe = subscribe;
            }
        }
        /**
         * Creates a new Observable, with this Observable as the source, and the passed
         * operator defined as the new observable's operator.
         * @method lift
         * @param {Operator} operator the operator defining the operation to take on the observable
         * @return {Observable} a new observable with the Operator applied
         */
        Observable.prototype.lift = function (operator) {
            var observable = new Observable();
            observable.source = this;
            observable.operator = operator;
            return observable;
        };
        /**
         * Registers handlers for handling emitted values, error and completions from the observable, and
         *  executes the observable's subscriber function, which will take action to set up the underlying data stream
         * @method subscribe
         * @param {PartialObserver|Function} observerOrNext (optional) either an observer defining all functions to be called,
         *  or the first of three possible handlers, which is the handler for each value emitted from the observable.
         * @param {Function} error (optional) a handler for a terminal event resulting from an error. If no error handler is provided,
         *  the error will be thrown as unhandled
         * @param {Function} complete (optional) a handler for a terminal event resulting from successful completion.
         * @return {ISubscription} a subscription reference to the registered handlers
         */
        Observable.prototype.subscribe = function (observerOrNext, error, complete) {
            var operator = this.operator;
            var sink = toSubscriber(observerOrNext, error, complete);
            sink.add(operator ? operator.call(sink, this) : this._subscribe(sink));
            if (sink.syncErrorThrowable) {
                sink.syncErrorThrowable = false;
                if (sink.syncErrorThrown) {
                    throw sink.syncErrorValue;
                }
            }
            return sink;
        };
        /**
         * @method forEach
         * @param {Function} next a handler for each value emitted by the observable
         * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise
         * @return {Promise} a promise that either resolves on observable completion or
         *  rejects with the handled error
         */
        Observable.prototype.forEach = function (next, PromiseCtor) {
            var _this = this;
            if (!PromiseCtor) {
                if (root.Rx && root.Rx.config && root.Rx.config.Promise) {
                    PromiseCtor = root.Rx.config.Promise;
                }
                else if (root.Promise) {
                    PromiseCtor = root.Promise;
                }
            }
            if (!PromiseCtor) {
                throw new Error('no Promise impl found');
            }
            return new PromiseCtor(function (resolve, reject) {
                var subscription = _this.subscribe(function (value) {
                    if (subscription) {
                        // if there is a subscription, then we can surmise
                        // the next handling is asynchronous. Any errors thrown
                        // need to be rejected explicitly and unsubscribe must be
                        // called manually
                        try {
                            next(value);
                        }
                        catch (err) {
                            reject(err);
                            subscription.unsubscribe();
                        }
                    }
                    else {
                        // if there is NO subscription, then we're getting a nexted
                        // value synchronously during subscription. We can just call it.
                        // If it errors, Observable's `subscribe` imple will ensure the
                        // unsubscription logic is called, then synchronously rethrow the error.
                        // After that, Promise will trap the error and send it
                        // down the rejection path.
                        next(value);
                    }
                }, reject, resolve);
            });
        };
        Observable.prototype._subscribe = function (subscriber) {
            return this.source.subscribe(subscriber);
        };
        /**
         * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable
         * @method Symbol.observable
         * @return {Observable} this instance of the observable
         */
        Observable.prototype[$$observable] = function () {
            return this;
        };
        return Observable;
    }());
    // HACK: Since TypeScript inherits static properties too, we have to
    // fight against TypeScript here so Subject can have a different static create signature
    /**
     * Creates a new cold Observable by calling the Observable constructor
     * @static true
     * @owner Observable
     * @method create
     * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor
     * @return {Observable} a new cold observable
     */
    Observable.create = function (subscribe) {
        return new Observable(subscribe);
    };
    /**
     * ANGULAR 2 LOCALIZATION
     * An Angular 2 library to translate messages, dates and numbers.
     * Written by Roberto Simonetti.
     * MIT license.
     * https://github.com/robisim74/angular2localization
     */
    var __decorate$1 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata$1 = (undefined && undefined.__metadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(k, v);
    };
    /**
     * LocaleService class.
     * Defines language, default locale & currency.
     *
     * Instantiate this class only once in the route component in order to access the data of location from anywhere in the application:
     *
     * FIRST SCENARIO - Dates & numbers.
     *
     * import {LocaleService} from 'angular2localization/angular2localization';
     *
     * @Component({
     *     selector: 'app-component',
     *     ...
     *     providers: [LocaleService] // Inherited by all descendants.
     * })
     *
     * export class AppComponent {
     *
     *     constructor(public locale: LocaleService) {
     *
     *         // Required: default language (ISO 639 two-letter or three-letter code) and country (ISO 3166 two-letter, uppercase code).
     *         this.locale.definePreferredLocale('en', 'US');
     *
     *         // Optional: default currency (ISO 4217 three-letter code).
     *         this.locale.definePreferredCurrency('USD');
     *
     *      }
     *
     * }
     *
     * SECOND SCENARIO - Messages.
     *
     * import {LocaleService, LocalizationService} from 'angular2localization/angular2localization';
     *
     * @Component({
     *     selector: 'app-component',
     *     ...
     *     providers: [LocaleService, LocalizationService] // Inherited by all descendants.
     * })
     *
     * export class AppComponent {
     *
     *     constructor(public locale: LocaleService, public localization: LocalizationService) {
     *
     *         // Adds a new language (ISO 639 two-letter or three-letter code).
     *         this.locale.addLanguage('en');
     *         // Add a new language here.
     *
     *         // Required: default language and expiry (No days). If the expiry is omitted, the cookie becomes a session cookie.
     *         this.locale.definePreferredLanguage('en', 30);
     *
     *     }
     *
     * }
     *
     * THIRD SCENARIO - Messages, dates & numbers.
     *
     * import {LocaleService, LocalizationService} from 'angular2localization/angular2localization';
     *
     * @Component({
     *     selector: 'app-component',
     *     ...
     *     providers: [LocaleService, LocalizationService] // Inherited by all descendants.
     * })
     *
     * export class AppComponent {
     *
     *     constructor(public locale: LocaleService, public localization: LocalizationService) {
     *
     *         // Adds a new language (ISO 639 two-letter or three-letter code).
     *         this.locale.addLanguage('en');
     *         // Add a new language here.
     *
     *         // Required: default language, country (ISO 3166 two-letter, uppercase code) and expiry (No days). If the expiry is omitted, the cookie becomes a session cookie.
     *         this.locale.definePreferredLocale('en', 'US', 30);
     *
     *         // Optional: default currency (ISO 4217 three-letter code).
     *         this.locale.definePreferredCurrency('USD');
     *
     *     }
     *
     * }
     *
     * Changing language.
     *
     * To change language at runtime, call the following method:
     *
     * this.locale.setCurrentLanguage(language);
     *
     * where 'language' is the two-letter or three-letter code of the new language (ISO 639).
     *
     *
     * Changing locale.
     *
     * To change locale at runtime, call the following method:
     *
     * this.locale.setCurrentLocale(language, country);
     *
     * where 'language' is the two-letter or three-letter code of the new language (ISO 639)
     * and 'country' is the two-letter, uppercase code of the new country (ISO 3166).
     *
     *
     * Changing currency.
     *
     * To change currency at runtime, call the following method:
     *
     * this.locale.setCurrentCurrency(currency);
     *
     * where 'currency' is the three-letter code of the new currency (ISO 4217).
     *
     * @author Roberto Simonetti
     */
    var LocaleService_1;
    exports.LocaleService = LocaleService_1 = (function () {
        function LocaleService() {
            /**
             * Output for event current language code changed.
             */
            this.languageCodeChanged = new _angular_core.EventEmitter();
            /**
             * Output for event current country code changed.
             */
            this.countryCodeChanged = new _angular_core.EventEmitter();
            /**
             * Output for event current currency code changed.
             */
            this.currencyCodeChanged = new _angular_core.EventEmitter();
            /**
             * Output for event script code changed.
             */
            this.scriptCodeChanged = new _angular_core.EventEmitter();
            /**
             * Output for event numbering system changed.
             */
            this.numberingSystemChanged = new _angular_core.EventEmitter();
            /**
             * Output for event calendar changed.
             */
            this.calendarChanged = new _angular_core.EventEmitter();
            /**
             * Enable/disable cookie.
             */
            this.enableCookie = false;
            /**
             * Enable/disable Local Storage.
             */
            this.enableLocalStorage = false;
            /**
             * The available language codes.
             */
            this.languageCodes = [];
            this.languageCode = "";
            this.countryCode = "";
            this.currencyCode = "";
            this.defaultLocale = "";
            this.scriptCode = "";
            this.numberingSystem = "";
            this.calendar = "";
            // Counts the reference to the service.
            LocaleService_1.referenceCounter++;
            // Enables the cookies for the first instance of the service (see issue #11).
            if (LocaleService_1.referenceCounter == 1) {
                this.enableCookie = true;
            }
        }
        /**
         * Adds a new language.
         *
         * @param language The two-letter or three-letter code of the new language
         */
        LocaleService.prototype.addLanguage = function (language) {
            this.languageCodes.push(language);
        };
        /**
         * Sets Local Storage as default.
         */
        LocaleService.prototype.useLocalStorage = function () {
            this.enableLocalStorage = true;
        };
        /**
         * Defines the preferred language.
         * Selects the current language of the browser if it has been added, else the default language.
         *
         * @param defaultLanguage The two-letter or three-letter code of the default language
         * @param expiry Number of days on the expiry. If omitted, the cookie becomes a session cookie
         */
        LocaleService.prototype.definePreferredLanguage = function (defaultLanguage, expiry) {
            this.expiry = expiry;
            // Parses the storage "locale" to extract the codes.
            this.parseStorage("locale");
            if (this.languageCode == "") {
                this.languageCode = defaultLanguage;
                // Verifies browser language.
                var browserLanguage = "";
                if (typeof navigator.language != "undefined") {
                    browserLanguage = navigator.language;
                }
                else if (typeof navigator.userLanguage != "undefined") {
                    browserLanguage = navigator.userLanguage;
                }
                else if (typeof navigator.browserLanguage != "undefined") {
                    browserLanguage = navigator.browserLanguage;
                }
                else if (typeof navigator.systemLanguage != "undefined") {
                    browserLanguage = navigator.systemLanguage;
                }
                // Tries to gets the current language of browser.
                if (browserLanguage != "") {
                    var index = browserLanguage.indexOf("-");
                    if (index != -1) {
                        browserLanguage = browserLanguage.substring(0, index); // Gets the language code.
                    }
                    if (this.languageCodes.length > 0 && this.languageCodes.indexOf(browserLanguage) != -1) {
                        this.languageCode = browserLanguage;
                    }
                }
            }
            // Sets the default locale.
            this.setDefaultLocale();
        };
        /**
         * Defines preferred languange and country, regardless of the browser language.
         *
         * @param defaultLanguage The two-letter or three-letter code of the default language
         * @param defaultCountry The two-letter, uppercase code of the default country
         * @param expiry Number of days on the expiry. If omitted, the cookie becomes a session cookie
         * @param script The optional four-letter script code
         * @param numberingSystem The optional numbering system to be used
         * @param calendar The optional calendar to be used
         */
        LocaleService.prototype.definePreferredLocale = function (defaultLanguage, defaultCountry, expiry, script, numberingSystem, calendar) {
            if (script === void 0) { script = ""; }
            if (numberingSystem === void 0) { numberingSystem = ""; }
            if (calendar === void 0) { calendar = ""; }
            this.expiry = expiry;
            // Parses the storage "locale" to extract the codes & the extension.
            this.parseStorage("locale");
            if (this.languageCode == "" || this.countryCode == "") {
                this.languageCode = defaultLanguage;
                this.countryCode = defaultCountry;
                this.scriptCode = script;
                this.numberingSystem = numberingSystem;
                this.calendar = calendar;
            }
            // Sets the default locale.
            this.setDefaultLocale();
        };
        /**
         * Defines the preferred currency.
         *
         * @param defaultCurrency The three-letter code of the default currency
         */
        LocaleService.prototype.definePreferredCurrency = function (defaultCurrency) {
            // Parses the storage "currency" to extract the code.
            this.parseStorage("currency");
            if (this.currencyCode == "") {
                this.currencyCode = defaultCurrency;
            }
            // Sets the storage "currency".
            this.setStorage("currency", this.currencyCode);
        };
        /**
         * Gets the current language.
         *
         * @return The two-letter or three-letter code of the current language
         */
        LocaleService.prototype.getCurrentLanguage = function () {
            return this.languageCode;
        };
        /**
         * Gets the current country.
         *
         * @return The two-letter, uppercase code of the current country
         */
        LocaleService.prototype.getCurrentCountry = function () {
            return this.countryCode;
        };
        /**
         * Gets the current currency.
         *
         * @return The three-letter code of the current currency
         */
        LocaleService.prototype.getCurrentCurrency = function () {
            return this.currencyCode;
        };
        /**
         * Gets the script.
         *
         * @return The four-letter code of the script
         */
        LocaleService.prototype.getScript = function () {
            return this.scriptCode;
        };
        /**
         * Gets the numbering system.
         *
         * @return The numbering system
         */
        LocaleService.prototype.getNumberingSystem = function () {
            return this.numberingSystem;
        };
        /**
         * Gets the calendar.
         *
         * @return The calendar
         */
        LocaleService.prototype.getCalendar = function () {
            return this.calendar;
        };
        /**
         * Sets the current language.
         *
         * @param language The two-letter or three-letter code of the new language
         */
        LocaleService.prototype.setCurrentLanguage = function (language) {
            // Checks if the language has changed.
            if (this.languageCode != language) {
                // Assigns the value & sends an event.
                this.languageCode = language;
                this.languageCodeChanged.emit(language);
                // Sets the default locale.
                this.setDefaultLocale();
            }
        };
        /**
         * Sets the current locale.
         *
         * @param language The two-letter or three-letter code of the new language
         * @param country The two-letter, uppercase code of the new country
         * @param script The optional four-letter script code
         * @param numberingSystem The optional numbering system to be used
         * @param calendar The optional calendar to be used
         */
        LocaleService.prototype.setCurrentLocale = function (language, country, script, numberingSystem, calendar) {
            if (script === void 0) { script = ""; }
            if (numberingSystem === void 0) { numberingSystem = ""; }
            if (calendar === void 0) { calendar = ""; }
            // Checks if language, country, script or extension have changed.
            if (this.languageCode != language || this.countryCode != country || this.scriptCode != script || this.numberingSystem != numberingSystem || this.calendar != calendar) {
                // Assigns the values & sends the events.
                if (this.languageCode != language) {
                    this.languageCode = language;
                    this.languageCodeChanged.emit(language);
                }
                if (this.countryCode != country) {
                    this.countryCode = country;
                    this.countryCodeChanged.emit(country);
                }
                if (this.scriptCode != script) {
                    this.scriptCode = script;
                    this.scriptCodeChanged.emit(script);
                }
                if (this.numberingSystem != numberingSystem) {
                    this.numberingSystem = numberingSystem;
                    this.numberingSystemChanged.emit(numberingSystem);
                }
                if (this.calendar != calendar) {
                    this.calendar = calendar;
                    this.calendarChanged.emit(calendar);
                }
                // Sets the default locale.
                this.setDefaultLocale();
            }
        };
        /**
         * Sets the current currency.
         *
         * @param currency The three-letter code of the new currency
         */
        LocaleService.prototype.setCurrentCurrency = function (currency) {
            // Checks if the currency has changed.
            if (this.currencyCode != currency) {
                // Assigns the value & sends an event.
                this.currencyCode = currency;
                this.currencyCodeChanged.emit(currency);
                // Sets the storage "currency".
                this.setStorage("currency", this.currencyCode);
            }
        };
        /**
         * Gets the default locale.
         *
         * @return The default locale
         */
        LocaleService.prototype.getDefaultLocale = function () {
            return this.defaultLocale;
        };
        /**
         * Builds the default locale.
         */
        LocaleService.prototype.setDefaultLocale = function () {
            this.defaultLocale = this.languageCode;
            this.defaultLocale += this.scriptCode != "" ? "-" + this.scriptCode : "";
            this.defaultLocale += this.countryCode != "" ? "-" + this.countryCode : "";
            // Adds the 'u' (Unicode) extension.
            this.defaultLocale += this.numberingSystem != "" || this.calendar != "" ? "-u" : "";
            // Adds numbering system.
            this.defaultLocale += this.numberingSystem != "" ? "-nu-" + this.numberingSystem : "";
            // Adds calendar.
            this.defaultLocale += this.calendar != "" ? "-ca-" + this.calendar : "";
            // Sets the storage "locale".
            this.setStorage("locale", this.defaultLocale);
        };
        /**
         * Parses the storage to extract the codes & the extension.
         *
         * @param name The name of the storage
         */
        LocaleService.prototype.parseStorage = function (name) {
            var storage = "";
            if (this.enableLocalStorage && this.verifyLocalStorage) {
                storage = this.getLocalStorage(name);
            }
            else if (this.enableCookie && this.languageCodes.length > 0 && this.verifyCookie) {
                storage = this.getCookie(name);
            }
            if (storage != "") {
                // Looks for the 'u' (Unicode) extension.
                var index = storage.search("-u");
                if (index != -1) {
                    var extensions = storage.substring(index + 1).split("-");
                    switch (extensions.length) {
                        case 3:
                            if (extensions[1] == "nu") {
                                this.numberingSystem = extensions[2];
                            }
                            else if (extensions[1] == "ca") {
                                this.calendar = extensions[2];
                            }
                            break;
                        case 5:
                            this.numberingSystem = extensions[2];
                            this.calendar = extensions[4];
                            break;
                    }
                    // Extracts the codes.
                    storage = storage.substring(0, index);
                }
                // Splits the string to each hyphen.
                var codes = storage.split("-");
                switch (codes.length) {
                    case 1:
                        if (name == "locale") {
                            this.languageCode = codes[0];
                        }
                        else if (name == "currency") {
                            this.currencyCode = codes[0];
                        }
                        break;
                    case 2:
                        this.languageCode = codes[0];
                        this.countryCode = codes[1];
                        break;
                    case 3:
                        this.languageCode = codes[0];
                        this.scriptCode = codes[1];
                        this.countryCode = codes[2];
                        break;
                }
            }
        };
        /**
         * Checks browser support for Local Storage.
         *
         * @return True if Web Storage is supported.
         */
        LocaleService.prototype.verifyLocalStorage = function () {
            return typeof Storage != "undefined";
        };
        /**
         * Checks browser support for cookies.
         *
         * @return True if cookies are supported.
         */
        LocaleService.prototype.verifyCookie = function () {
            return typeof navigator.cookieEnabled != "undefined" && navigator.cookieEnabled;
        };
        /**
         * Sets the storage.
         *
         * @param name The name of the storage
         * @param value The value of the storage
         */
        LocaleService.prototype.setStorage = function (name, value) {
            if (this.enableLocalStorage && this.verifyLocalStorage) {
                this.setLocalStorage(name, value);
            }
            else if (this.enableCookie == true && this.languageCodes.length > 0 && this.verifyCookie) {
                this.setCookie(name, value, this.expiry);
            }
        };
        /**
         * Saves Local Storage value.
         *
         * @param name The name of the storage
         * @param value The value of the storage
         */
        LocaleService.prototype.setLocalStorage = function (name, value) {
            localStorage.setItem(name, value);
        };
        /**
         * Saves Local Storage value.
         *
         * @param name The name of the storage
         * @return The value of the storage
         */
        LocaleService.prototype.getLocalStorage = function (name) {
            // If the storage is not found, returns an empty string.
            return localStorage.getItem(name) != null ? localStorage.getItem(name) : "";
        };
        /**
         * Sets the cookie.
         *
         * @param name The name of the cookie
         * @param value The value of the cookie
         * @param days Number of days on the expiry
         */
        LocaleService.prototype.setCookie = function (name, value, days) {
            if (days != null) {
                // Adds the expiry date (in UTC time).
                var expirationDate = new Date();
                expirationDate.setTime(expirationDate.getTime() + (days * 24 * 60 * 60 * 1000));
                var expires = "; expires=" + expirationDate.toUTCString();
            }
            else {
                // By default, the cookie is deleted when the browser is closed.
                var expires = "";
            }
            // Creates the cookie.
            document.cookie = name + "=" + value + expires + "; path=/";
        };
        /**
         * Gets the cookie.
         *
         * @param name The name of the cookie
         * @return The value of the cookie
         */
        LocaleService.prototype.getCookie = function (name) {
            // The text to search for.
            name += "=";
            // Splits document.cookie on semicolons into an array.
            var ca = document.cookie.split(";");
            // Loops through the ca array, and reads out each value.
            for (var i = 0; i < ca.length; i++) {
                var c = ca[i];
                while (c.charAt(0) == " ") {
                    c = c.substring(1);
                }
                // If the cookie is found, returns the value of the cookie.
                if (c.indexOf(name) == 0) {
                    return c.substring(name.length, c.length);
                }
            }
            // If the cookie is not found, returns an empty string.
            return "";
        };
        return LocaleService;
    }());
    /**
     * Reference counter for the service.
     */
    exports.LocaleService.referenceCounter = 0;
    __decorate$1([
        _angular_core.Output(),
        __metadata$1('design:type', _angular_core.EventEmitter)
    ], exports.LocaleService.prototype, "languageCodeChanged", void 0);
    __decorate$1([
        _angular_core.Output(),
        __metadata$1('design:type', _angular_core.EventEmitter)
    ], exports.LocaleService.prototype, "countryCodeChanged", void 0);
    __decorate$1([
        _angular_core.Output(),
        __metadata$1('design:type', _angular_core.EventEmitter)
    ], exports.LocaleService.prototype, "currencyCodeChanged", void 0);
    __decorate$1([
        _angular_core.Output(),
        __metadata$1('design:type', _angular_core.EventEmitter)
    ], exports.LocaleService.prototype, "scriptCodeChanged", void 0);
    __decorate$1([
        _angular_core.Output(),
        __metadata$1('design:type', _angular_core.EventEmitter)
    ], exports.LocaleService.prototype, "numberingSystemChanged", void 0);
    __decorate$1([
        _angular_core.Output(),
        __metadata$1('design:type', _angular_core.EventEmitter)
    ], exports.LocaleService.prototype, "calendarChanged", void 0);
    exports.LocaleService = LocaleService_1 = __decorate$1([
        _angular_core.Injectable(),
        __metadata$1('design:paramtypes', [])
    ], exports.LocaleService);
    /**
     * ANGULAR 2 LOCALIZATION
     * An Angular 2 library to translate messages, dates and numbers.
     * Written by Roberto Simonetti.
     * MIT license.
     * https://github.com/robisim74/angular2localization
     */
    /**
     * IntlSupport class.
     * Provides the methods to check if Intl is supported.
     *
     * @author Roberto Simonetti
     */
    var IntlSupport = (function () {
        function IntlSupport() {
        }
        /**
         * Support for dates.
         *
         * @param defaultLocale The default locale
         * @return True if the browser supports locales for dates, otherwise false.
         */
        IntlSupport.DateTimeFormat = function (defaultLocale) {
            // Checking for support.
            try {
                new Intl.DateTimeFormat(defaultLocale).format(new Date());
            }
            catch (e) {
                return false;
            }
            return true;
        };
        /**
         * Support for numbers.
         *
         * @param defaultLocale The default locale
         * @return True if the browser supports locales for numbers, otherwise false.
         */
        IntlSupport.NumberFormat = function (defaultLocale) {
            // Checking for support.
            try {
                var n = 0;
                new Intl.NumberFormat(defaultLocale).format(n);
            }
            catch (e) {
                return false;
            }
            return true;
        };
        /**
         * Support for Collator.
         *
         * @param lang The current language code
         * @return True if the browser supports Collator, otherwise false.
         */
        IntlSupport.Collator = function (lang) {
            // Checking for support.
            try {
                var value1 = "a";
                var value2 = "b";
                new Intl.Collator(lang).compare(value1, value2);
            }
            catch (e) {
                return false;
            }
            return true;
        };
        return IntlSupport;
    }());
    /**
     * ANGULAR 2 LOCALIZATION
     * An Angular 2 library to translate messages, dates and numbers.
     * Written by Roberto Simonetti.
     * MIT license.
     * https://github.com/robisim74/angular2localization
     */
    var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata = (undefined && undefined.__metadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(k, v);
    };
    /**
     * LocalizationService class.
     * Gets the translation data and performs operations.
     *
     * Direct loading.
     *
     * To initialize LocalizationService for the direct loading, add the following code in the body of constructor of the route component:
     *
     * var translationEN = {
     *      TITLE: 'Angular 2 Localization',
     *      CHANGE_LANGUAGE: 'Change language',
     *      ...
     * }
     * // Add a new translation here.
     *
     * // Required: adds a new translation with the given language code.
     * this.localization.addTranslation('en', translationEN);
     * // Add a new translation with the given language code here.
     * this.localization.updateTranslation(); // Need to update the translation.
     *
     * Asynchronous loading.
     *
     * To initialize LocalizationService for the asynchronous loading, add the following code in the body of constructor of the route component:
     *
     * // Required: initializes the translation provider with the given path prefix.
     * this.localization.translationProvider('./resources/locale-');
     * this.localization.updateTranslation(); // Need to update the translation.
     *
     * and create the json files of the translations such as 'locale-en.json':
     *
     * {
     *     "TITLE": "Angular 2 Localization",
     *     "CHANGE_LANGUAGE": "Change language",
     *     ...
     * }
     *
     * @author Roberto Simonetti
     */
    exports.LocalizationService = (function () {
        function LocalizationService(http, locale) {
            var _this = this;
            this.http = http;
            this.locale = locale;
            /**
             * The translation data: {languageCode: {key: value}}.
             */
            this.translationData = {};
            this.prefix = "";
            this.loadingMode = exports.LoadingMode.Unknown;
            this.languageCode = "";
            // Initializes the loading mode.
            this.loadingMode = exports.LoadingMode.Direct;
            // Initializes the service state.
            this.serviceState = exports.ServiceState.isWaiting;
            // When the language changes, subscribes to the event & call updateTranslation method.
            this.locale.languageCodeChanged.subscribe(
            // Generator or next.
            function (language) { return _this.updateTranslation(language); });
        }
        /**
         * Direct loading: adds new translation data.
         *
         * @param language The two-letter code of the language for the translation data
         * @param translation The new translation data
         */
        LocalizationService.prototype.addTranslation = function (language, translation) {
            // Adds the new translation data.
            this.translationData[language] = translation;
        };
        /**
         * Asynchronous loading: defines the translation provider.
         *
         * @param prefix The path prefix of the json files
         * @param dataFormat Data format: default value is 'json'.
         * @param webAPI True if the asynchronous loading uses a Web API to get the data.
         */
        LocalizationService.prototype.translationProvider = function (prefix, dataFormat, webAPI) {
            if (dataFormat === void 0) { dataFormat = "json"; }
            if (webAPI === void 0) { webAPI = false; }
            this.prefix = prefix;
            this.dataFormat = dataFormat;
            this.webAPI = webAPI;
            // Updates the loading mode.
            this.loadingMode = exports.LoadingMode.Async;
        };
        /**
         * Translates a key.
         *
         * @param key The key to be translated
         * @return The value of translation
         */
        LocalizationService.prototype.translate = function (key) {
            var value;
            if (this.translationData[this.languageCode] != null) {
                // Gets the translation by language code. 
                var translation = this.translationData[this.languageCode];
                // Gets the value of translation by key.   
                value = translation[key];
            }
            // If the value of translation is not present, the same key is returned (see issue #1).
            if (value == null || value == "") {
                value = key;
            }
            return value;
        };
        /**
         * Translates a key.
         *
         * @param key The key to be translated
         * @return An observable of the value of translation
         */
        LocalizationService.prototype.translateAsync = function (key) {
            var _this = this;
            return new Observable(function (observer) {
                // Gets the value of translation for the key.
                var value = _this.translate(key);
                observer.next(value);
                observer.complete();
            });
        };
        /**
         * Updates the language code and loads the translation data for the asynchronous loading.
         *
         * @param language The two-letter or three-letter code of the language
         */
        LocalizationService.prototype.updateTranslation = function (language) {
            if (language === void 0) { language = this.locale.getCurrentLanguage(); }
            if (language != "" && language != this.languageCode) {
                // Asynchronous loading.
                if (this.loadingMode == exports.LoadingMode.Async) {
                    // Updates the translation data.  
                    this.getTranslation(language);
                }
                else {
                    // Updates the language code of the service.
                    this.languageCode = language;
                    // Updates the service state.
                    this.serviceState = exports.ServiceState.isReady;
                }
            }
        };
        /* Intl.Collator */
        /**
         * Compares two keys by the value of translation & the current language code.
         *
         * @param key1, key2 The keys of the values to compare
         * @param extension
         * @param options
         * @return A negative value if the value of translation of key1 comes before the value of translation of key2; a positive value if key1 comes after key2; 0 if they are considered equal or Intl.Collator is not supported
         * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Collator
         */
        LocalizationService.prototype.compare = function (key1, key2, extension, options) {
            // Checks for support for Intl.
            if (IntlSupport.Collator(this.languageCode) == false) {
                return 0;
            }
            // Gets the value of translation for the keys.
            var value1 = this.translate(key1);
            var value2 = this.translate(key2);
            var locale = this.addExtension(this.languageCode, extension);
            return new Intl.Collator(locale).compare(value1, value2);
        };
        /**
         * Sorts an array of objects or an array of arrays by the current language code.
         *
         * @param list The array to be sorted
         * @param keyName The column that contains the keys of the values to be ordered
         * @param order 'asc' or 'desc'. The default value is 'asc'.
         * @param extension
         * @param options
         * @return The same sorted list or the same list if Intl.Collator is not supported
         * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Collator
         */
        LocalizationService.prototype.sort = function (list, keyName, order, extension, options) {
            if (list == null || keyName == null || IntlSupport.Collator(this.languageCode) == false) {
                return list;
            }
            // Gets the value of translation for the keys.
            for (var _i = 0, list_1 = list; _i < list_1.length; _i++) {
                var item = list_1[_i];
                // Gets the value of translation for the key.
                var value = this.translate(item[keyName]);
                // Adds a new column for translated values.
                var translated = keyName.concat("Translated");
                // Updates the value in the list.
                item[translated] = value;
            }
            var locale = this.addExtension(this.languageCode, extension);
            // Intl.Collator.
            var collator = new Intl.Collator(locale, options); // It can be passed directly to Array.prototype.sort.
            list.sort(function (a, b) {
                return collator.compare(a[translated], b[translated]);
            });
            // Removes the column of translated values.
            var index = list.indexOf(translated, 0);
            if (index > -1) {
                list.splice(index, 1);
            }
            // Descending order.
            if (order != null && order == "desc") {
                list.reverse();
            }
            return list;
        };
        /**
         * Sorts an array of objects or an array of arrays by the current language code.
         *
         * @param list The array to be sorted
         * @param keyName The column that contains the keys of the values to be ordered
         * @param order 'asc' or 'desc'. The default value is 'asc'.
         * @param extension
         * @param options
         * @return An observable of the sorted list or of the same list if Intl.Collator is not supported
         * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Collator
         */
        LocalizationService.prototype.sortAsync = function (list, keyName, order, extension, options) {
            var _this = this;
            return new Observable(function (observer) {
                // Gets the sorted list.
                observer.next(_this.sort(list, keyName, order, extension, options));
                observer.complete();
            });
        };
        /**
         * Matches a string into an array of objects or an array of arrays.
         *
         * @param s The string to search
         * @param list The array to look for
         * @param keyNames An array that contains the columns to look for
         * @param options
         * @return A filtered list or the same list if Intl.Collator is not supported
         * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Collator
         */
        LocalizationService.prototype.search = function (s, list, keyNames, options) {
            var _this = this;
            if (options === void 0) { options = { usage: 'search' }; }
            if (list == null || keyNames == null || s == "" || IntlSupport.Collator(this.languageCode) == false) {
                return list;
            }
            // Gets the value of translation for the each column.
            var translated = new Array();
            var i = 0;
            for (var i = 0; i < keyNames.length; i++) {
                // Adds a new column for translated values.
                translated.push(keyNames[i].concat("Translated"));
                for (var _i = 0, list_2 = list; _i < list_2.length; _i++) {
                    var item = list_2[_i];
                    // Gets the values of translation for the column.
                    var value = this.translate(item[keyNames[i]]);
                    // Updates the value in the list.
                    item[translated[i]] = value;
                }
            }
            var locale = this.languageCode;
            // Intl.Collator.
            var collator = new Intl.Collator(locale, options);
            var matches = list.filter(function (v) {
                var found = false;
                for (var i = 0; i < translated.length; i++) {
                    // Calls matching algorithm.
                    if (_this.match(v[translated[i]], s, collator)) {
                        found = true;
                        break;
                    }
                }
                return found;
            });
            // Removes the columns of translated values.
            for (var i = 0; i < translated.length; i++) {
                var index = matches.indexOf(translated[i], 0);
                if (index > -1) {
                    matches.splice(index, 1);
                }
            }
            return matches;
        };
        /**
         * Matches a string into an array of objects or an array of arrays.
         *
         * @param s The string to search
         * @param list The array to look for
         * @param keyNames An array that contains the columns to look for
         * @param options
         * @return An observable for each element of the filtered list or the same list if Intl.Collator is not supported
         * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Collator
         */
        LocalizationService.prototype.searchAsync = function (s, list, keyNames, options) {
            var _this = this;
            if (options === void 0) { options = { usage: 'search' }; }
            if (list == null) {
                return null;
            }
            if (keyNames == null || s == "" || IntlSupport.Collator(this.languageCode) == false) {
                return new Observable(function (observer) {
                    for (var _i = 0, list_3 = list; _i < list_3.length; _i++) {
                        var item = list_3[_i];
                        observer.next(item);
                    }
                    observer.complete();
                });
            }
            return new Observable(function (observer) {
                // Gets the value of translation for the each column.
                var translated = new Array();
                var i = 0;
                for (var i = 0; i < keyNames.length; i++) {
                    // Adds a new column for translated values.
                    translated.push(keyNames[i].concat("Translated"));
                    for (var _i = 0, list_4 = list; _i < list_4.length; _i++) {
                        var item = list_4[_i];
                        // Gets the values of translation for the column.
                        var value = _this.translate(item[keyNames[i]]);
                        // Updates the value in the list.
                        item[translated[i]] = value;
                    }
                }
                var locale = _this.languageCode;
                // Intl.Collator.
                var collator = new Intl.Collator(locale, options);
                for (var _a = 0, list_5 = list; _a < list_5.length; _a++) {
                    var v = list_5[_a];
                    for (var i = 0; i < translated.length; i++) {
                        // Calls matching algorithm.
                        if (_this.match(v[translated[i]], s, collator)) {
                            observer.next(v);
                            break;
                        }
                    }
                }
                // Removes the columns of translated values.
                for (var i = 0; i < translated.length; i++) {
                    var index = list.indexOf(translated[i], 0);
                    if (index > -1) {
                        list.splice(index, 1);
                    }
                }
                observer.complete();
            });
        };
        LocalizationService.prototype.addExtension = function (locale, extension) {
            // Adds extension.
            if (extension != null && extension != "") {
                locale = locale + "-" + extension;
            }
            return locale;
        };
        /**
         * Matching algorithm.
         *
         * @param v The value
         * @param s The string to search
         * return True if match, otherwise false
         */
        LocalizationService.prototype.match = function (v, s, collator) {
            var vLength = v.length;
            var sLength = s.length;
            if (sLength > vLength) {
                return false;
            } // The search string is longer than value.
            if (sLength == vLength) {
                return collator.compare(v, s) === 0;
            }
            // Tries to search the substring.
            var found = false;
            for (var i = 0; i < vLength - (sLength - 1); i++) {
                var str = v.substr(i, sLength);
                if (collator.compare(str, s) === 0) {
                    found = true;
                    break;
                }
            }
            return found;
        };
        /**
         * Asynchronous loading: gets translation data.
         *
         * @param language The two-letter or three-letter code of the language
         */
        LocalizationService.prototype.getTranslation = function (language) {
            var _this = this;
            // Initializes the translation data & the service state.
            this.translationData = {};
            this.serviceState = exports.ServiceState.isLoading;
            // Builds the URL.
            var url = this.prefix;
            if (this.webAPI == true) {
                // Absolute URL for Web API.
                url += language;
            }
            else {
                // Relative server path for 'json' files.
                url += language + "." + this.dataFormat;
            }
            // Angular 2 Http module.
            this.http.get(url)
                .map(function (res) { return res.json(); })
                .subscribe(
            // Observer or next.
            function (res) {
                // Assigns the observer to the translation data.
                _this.translationData[language] = res;
            }, 
            // Error.
            function (error) {
                console.error("Localization service:", error);
            }, 
            // Complete.
            function () {
                // Updates the service state.
                _this.serviceState = exports.ServiceState.isReady;
                // Updates the language code of the service.
                _this.languageCode = language;
            });
        };
        return LocalizationService;
    }());
    exports.LocalizationService = __decorate([
        _angular_core.Injectable(),
        __metadata('design:paramtypes', [_angular_http.Http, exports.LocaleService])
    ], exports.LocalizationService);
    /**
     * Defines the service state.
     */
    exports.ServiceState;
    (function (ServiceState) {
        /**
         * The translation data has been loaded.
         */
        ServiceState[ServiceState["isReady"] = 0] = "isReady";
        /**
         * The service is loading the data.
         */
        ServiceState[ServiceState["isLoading"] = 1] = "isLoading";
        /**
         * The service is waiting for the data.
         */
        ServiceState[ServiceState["isWaiting"] = 2] = "isWaiting";
    })(exports.ServiceState || (exports.ServiceState = {}));
    /**
     * Defines the loading mode.
     */
    exports.LoadingMode;
    (function (LoadingMode) {
        /**
         * Initial state.
         */
        LoadingMode[LoadingMode["Unknown"] = 0] = "Unknown";
        /**
         * Direct loading.
         */
        LoadingMode[LoadingMode["Direct"] = 1] = "Direct";
        /**
         * Asynchronous loading.
         */
        LoadingMode[LoadingMode["Async"] = 2] = "Async";
    })(exports.LoadingMode || (exports.LoadingMode = {}));
    /**
     * ANGULAR 2 LOCALIZATION
     * An Angular 2 library to translate messages, dates and numbers.
     * Written by Roberto Simonetti.
     * MIT license.
     * https://github.com/robisim74/angular2localization
     */
    /**
     * Locale superclass.
     * Provides the methods for localization.
     *
     * Extend this class in components to provide the necessary methods for localization:
     *
     * export class AppComponent extends Locale {
     *
     *     constructor(public locale: LocaleService, public localization: LocalizationService) {
     *         super(locale, localization);
     *
     *     }
     *
     * }
     *
     * @author Roberto Simonetti
     */
    var Locale = (function () {
        function Locale(locale, localization) {
            this.locale = locale;
            this.localization = localization;
        }
        Object.defineProperty(Locale.prototype, "lang", {
            // Gets the language code for the LocalizationService.
            get: function () {
                return this.localization.languageCode;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Locale.prototype, "defaultLocale", {
            // Gets the default locale.
            get: function () {
                return this.locale.getDefaultLocale();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Locale.prototype, "currency", {
            // Gets the current currency.
            get: function () {
                return this.locale.getCurrentCurrency();
            },
            enumerable: true,
            configurable: true
        });
        return Locale;
    }());
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var globalScope;
    if (typeof window === 'undefined') {
        if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {
            // TODO: Replace any with WorkerGlobalScope from lib.webworker.d.ts #3492
            globalScope = self;
        }
        else {
            globalScope = global;
        }
    }
    else {
        globalScope = window;
    }
    // Need to declare a new variable for global here since TypeScript
    // exports the original value of the symbol.
    var _global = globalScope;
    var Date$1 = _global.Date;
    // TODO: remove calls to assert in production environment
    // Note: Can't just export this and import in in other files
    // as `assert` is a reserved keyword in Dart
    _global.assert = function assert(condition) {
        // TODO: to be fixed properly via #2830, noop for now
    };
    function isPresent(obj) {
        return obj !== undefined && obj !== null;
    }
    function isBlank(obj) {
        return obj === undefined || obj === null;
    }
    function isNumber(obj) {
        return typeof obj === 'number';
    }
    function isString(obj) {
        return typeof obj === 'string';
    }
    function isDate(obj) {
        return obj instanceof Date$1 && !isNaN(obj.valueOf());
    }
    var NumberParseError = (function (_super) {
        __extends(NumberParseError, _super);
        function NumberParseError(message) {
            _super.call(this);
            this.message = message;
        }
        NumberParseError.prototype.toString = function () { return this.message; };
        return NumberParseError;
    }(Error));
    var NumberWrapper = (function () {
        function NumberWrapper() {
        }
        NumberWrapper.toFixed = function (n, fractionDigits) { return n.toFixed(fractionDigits); };
        NumberWrapper.equal = function (a, b) { return a === b; };
        NumberWrapper.parseIntAutoRadix = function (text) {
            var result = parseInt(text);
            if (isNaN(result)) {
                throw new NumberParseError('Invalid integer literal when parsing ' + text);
            }
            return result;
        };
        NumberWrapper.parseInt = function (text, radix) {
            if (radix == 10) {
                if (/^(\-|\+)?[0-9]+$/.test(text)) {
                    return parseInt(text, radix);
                }
            }
            else if (radix == 16) {
                if (/^(\-|\+)?[0-9ABCDEFabcdef]+$/.test(text)) {
                    return parseInt(text, radix);
                }
            }
            else {
                var result = parseInt(text, radix);
                if (!isNaN(result)) {
                    return result;
                }
            }
            throw new NumberParseError('Invalid integer literal when parsing ' + text + ' in base ' + radix);
        };
        // TODO: NaN is a valid literal but is returned by parseFloat to indicate an error.
        NumberWrapper.parseFloat = function (text) { return parseFloat(text); };
        Object.defineProperty(NumberWrapper, "NaN", {
            get: function () { return NaN; },
            enumerable: true,
            configurable: true
        });
        NumberWrapper.isNumeric = function (value) { return !isNaN(value - parseFloat(value)); };
        NumberWrapper.isNaN = function (value) { return isNaN(value); };
        NumberWrapper.isInteger = function (value) { return Number.isInteger(value); };
        return NumberWrapper;
    }());
    var RegExpWrapper = (function () {
        function RegExpWrapper() {
        }
        RegExpWrapper.create = function (regExpStr, flags) {
            if (flags === void 0) { flags = ''; }
            flags = flags.replace(/g/g, '');
            return new _global.RegExp(regExpStr, flags + 'g');
        };
        RegExpWrapper.firstMatch = function (regExp, input) {
            // Reset multimatch regex state
            regExp.lastIndex = 0;
            return regExp.exec(input);
        };
        RegExpWrapper.test = function (regExp, input) {
            regExp.lastIndex = 0;
            return regExp.test(input);
        };
        RegExpWrapper.matcher = function (regExp, input) {
            // Reset regex state for the case
            // someone did not loop over all matches
            // last time.
            regExp.lastIndex = 0;
            return { re: regExp, input: input };
        };
        RegExpWrapper.replaceAll = function (regExp, input, replace) {
            var c = regExp.exec(input);
            var res = '';
            regExp.lastIndex = 0;
            var prev = 0;
            while (c) {
                res += input.substring(prev, c.index);
                res += replace(c);
                prev = c.index + c[0].length;
                regExp.lastIndex = prev;
                c = regExp.exec(input);
            }
            res += input.substring(prev);
            return res;
        };
        return RegExpWrapper;
    }());
    var DateWrapper = (function () {
        function DateWrapper() {
        }
        DateWrapper.create = function (year, month, day, hour, minutes, seconds, milliseconds) {
            if (month === void 0) { month = 1; }
            if (day === void 0) { day = 1; }
            if (hour === void 0) { hour = 0; }
            if (minutes === void 0) { minutes = 0; }
            if (seconds === void 0) { seconds = 0; }
            if (milliseconds === void 0) { milliseconds = 0; }
            return new Date$1(year, month - 1, day, hour, minutes, seconds, milliseconds);
        };
        DateWrapper.fromISOString = function (str) { return new Date$1(str); };
        DateWrapper.fromMillis = function (ms) { return new Date$1(ms); };
        DateWrapper.toMillis = function (date) { return date.getTime(); };
        DateWrapper.now = function () { return new Date$1(); };
        DateWrapper.toJson = function (date) { return date.toJSON(); };
        return DateWrapper;
    }());
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var globalScope$1;
    if (typeof window === 'undefined') {
        if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {
            // TODO: Replace any with WorkerGlobalScope from lib.webworker.d.ts #3492
            globalScope$1 = self;
        }
        else {
            globalScope$1 = global;
        }
    }
    else {
        globalScope$1 = window;
    }
    // Need to declare a new variable for global here since TypeScript
    // exports the original value of the symbol.
    var global$1 = globalScope$1;
    // TODO: remove calls to assert in production environment
    // Note: Can't just export this and import in in other files
    // as `assert` is a reserved keyword in Dart
    global$1.assert = function assert(condition) {
        // TODO: to be fixed properly via #2830, noop for now
    };
    function isPresent$1(obj) {
        return obj !== undefined && obj !== null;
    }
    function isBlank$1(obj) {
        return obj === undefined || obj === null;
    }
    function isArray$2(obj) {
        return Array.isArray(obj);
    }
    function stringify$1(token) {
        if (typeof token === 'string') {
            return token;
        }
        if (token === undefined || token === null) {
            return '' + token;
        }
        if (token.name) {
            return token.name;
        }
        if (token.overriddenName) {
            return token.overriddenName;
        }
        var res = token.toString();
        var newLineIndex = res.indexOf('\n');
        return (newLineIndex === -1) ? res : res.substring(0, newLineIndex);
    }
    var Map$1 = global$1.Map;
    var Set = global$1.Set;
    // Safari and Internet Explorer do not support the iterable parameter to the
    // Map constructor.  We work around that by manually adding the items.
    var createMapFromPairs = (function () {
        try {
            if (new Map$1([[1, 2]]).size === 1) {
                return function createMapFromPairs(pairs) { return new Map$1(pairs); };
            }
        }
        catch (e) {
        }
        return function createMapAndPopulateFromPairs(pairs) {
            var map = new Map$1();
            for (var i = 0; i < pairs.length; i++) {
                var pair = pairs[i];
                map.set(pair[0], pair[1]);
            }
            return map;
        };
    })();
    var createMapFromMap = (function () {
        try {
            if (new Map$1(new Map$1())) {
                return function createMapFromMap(m) { return new Map$1(m); };
            }
        }
        catch (e) {
        }
        return function createMapAndPopulateFromMap(m) {
            var map = new Map$1();
            m.forEach(function (v, k) { map.set(k, v); });
            return map;
        };
    })();
    var _clearValues = (function () {
        if ((new Map$1()).keys().next) {
            return function _clearValues(m) {
                var keyIterator = m.keys();
                var k;
                while (!((k = keyIterator.next()).done)) {
                    m.set(k.value, null);
                }
            };
        }
        else {
            return function _clearValuesWithForeEach(m) {
                m.forEach(function (v, k) { m.set(k, null); });
            };
        }
    })();
    // Safari doesn't implement MapIterator.next(), which is used is Traceur's polyfill of Array.from
    // TODO(mlaval): remove the work around once we have a working polyfill of Array.from
    var _arrayFromMap = (function () {
        try {
            if ((new Map$1()).values().next) {
                return function createArrayFromMap(m, getValues) {
                    return getValues ? Array.from(m.values()) : Array.from(m.keys());
                };
            }
        }
        catch (e) {
        }
        return function createArrayFromMapWithForeach(m, getValues) {
            var res = ListWrapper.createFixedSize(m.size), i = 0;
            m.forEach(function (v, k) {
                res[i] = getValues ? v : k;
                i++;
            });
            return res;
        };
    })();
    var ListWrapper = (function () {
        function ListWrapper() {
        }
        // JS has no way to express a statically fixed size list, but dart does so we
        // keep both methods.
        ListWrapper.createFixedSize = function (size) { return new Array(size); };
        ListWrapper.createGrowableSize = function (size) { return new Array(size); };
        ListWrapper.clone = function (array) { return array.slice(0); };
        ListWrapper.forEachWithIndex = function (array, fn) {
            for (var i = 0; i < array.length; i++) {
                fn(array[i], i);
            }
        };
        ListWrapper.first = function (array) {
            if (!array)
                return null;
            return array[0];
        };
        ListWrapper.last = function (array) {
            if (!array || array.length == 0)
                return null;
            return array[array.length - 1];
        };
        ListWrapper.indexOf = function (array, value, startIndex) {
            if (startIndex === void 0) { startIndex = 0; }
            return array.indexOf(value, startIndex);
        };
        ListWrapper.contains = function (list, el) { return list.indexOf(el) !== -1; };
        ListWrapper.reversed = function (array) {
            var a = ListWrapper.clone(array);
            return a.reverse();
        };
        ListWrapper.concat = function (a, b) { return a.concat(b); };
        ListWrapper.insert = function (list, index, value) { list.splice(index, 0, value); };
        ListWrapper.removeAt = function (list, index) {
            var res = list[index];
            list.splice(index, 1);
            return res;
        };
        ListWrapper.removeAll = function (list, items) {
            for (var i = 0; i < items.length; ++i) {
                var index = list.indexOf(items[i]);
                list.splice(index, 1);
            }
        };
        ListWrapper.remove = function (list, el) {
            var index = list.indexOf(el);
            if (index > -1) {
                list.splice(index, 1);
                return true;
            }
            return false;
        };
        ListWrapper.clear = function (list) { list.length = 0; };
        ListWrapper.isEmpty = function (list) { return list.length == 0; };
        ListWrapper.fill = function (list, value, start, end) {
            if (start === void 0) { start = 0; }
            if (end === void 0) { end = null; }
            list.fill(value, start, end === null ? list.length : end);
        };
        ListWrapper.equals = function (a, b) {
            if (a.length != b.length)
                return false;
            for (var i = 0; i < a.length; ++i) {
                if (a[i] !== b[i])
                    return false;
            }
            return true;
        };
        ListWrapper.slice = function (l, from, to) {
            if (from === void 0) { from = 0; }
            if (to === void 0) { to = null; }
            return l.slice(from, to === null ? undefined : to);
        };
        ListWrapper.splice = function (l, from, length) { return l.splice(from, length); };
        ListWrapper.sort = function (l, compareFn) {
            if (isPresent$1(compareFn)) {
                l.sort(compareFn);
            }
            else {
                l.sort();
            }
        };
        ListWrapper.toString = function (l) { return l.toString(); };
        ListWrapper.toJSON = function (l) { return JSON.stringify(l); };
        ListWrapper.maximum = function (list, predicate) {
            if (list.length == 0) {
                return null;
            }
            var solution = null;
            var maxValue = -Infinity;
            for (var index = 0; index < list.length; index++) {
                var candidate = list[index];
                if (isBlank$1(candidate)) {
                    continue;
                }
                var candidateValue = predicate(candidate);
                if (candidateValue > maxValue) {
                    solution = candidate;
                    maxValue = candidateValue;
                }
            }
            return solution;
        };
        ListWrapper.flatten = function (list) {
            var target = [];
            _flattenArray(list, target);
            return target;
        };
        ListWrapper.addAll = function (list, source) {
            for (var i = 0; i < source.length; i++) {
                list.push(source[i]);
            }
        };
        return ListWrapper;
    }());
    function _flattenArray(source, target) {
        if (isPresent$1(source)) {
            for (var i = 0; i < source.length; i++) {
                var item = source[i];
                if (isArray$2(item)) {
                    _flattenArray(item, target);
                }
                else {
                    target.push(item);
                }
            }
        }
        return target;
    }
    // Safari and Internet Explorer do not support the iterable parameter to the
    // Set constructor.  We work around that by manually adding the items.
    var createSetFromList = (function () {
        var test = new Set([1, 2, 3]);
        if (test.size === 3) {
            return function createSetFromList(lst) { return new Set(lst); };
        }
        else {
            return function createSetAndPopulateFromList(lst) {
                var res = new Set(lst);
                if (res.size !== lst.length) {
                    for (var i = 0; i < lst.length; i++) {
                        res.add(lst[i]);
                    }
                }
                return res;
            };
        }
    })();
    /**
     * @stable
     */
    var BaseException = (function (_super) {
        __extends(BaseException, _super);
        function BaseException(message) {
            if (message === void 0) { message = '--'; }
            _super.call(this, message);
            this.message = message;
            this.stack = (new Error(message)).stack;
        }
        BaseException.prototype.toString = function () { return this.message; };
        return BaseException;
    }(Error));
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var NumberFormatStyle;
    (function (NumberFormatStyle) {
        NumberFormatStyle[NumberFormatStyle["Decimal"] = 0] = "Decimal";
        NumberFormatStyle[NumberFormatStyle["Percent"] = 1] = "Percent";
        NumberFormatStyle[NumberFormatStyle["Currency"] = 2] = "Currency";
    })(NumberFormatStyle || (NumberFormatStyle = {}));
    var NumberFormatter = (function () {
        function NumberFormatter() {
        }
        NumberFormatter.format = function (num, locale, style, _a) {
            var _b = _a === void 0 ? {} : _a, _c = _b.minimumIntegerDigits, minimumIntegerDigits = _c === void 0 ? 1 : _c, _d = _b.minimumFractionDigits, minimumFractionDigits = _d === void 0 ? 0 : _d, _e = _b.maximumFractionDigits, maximumFractionDigits = _e === void 0 ? 3 : _e, currency = _b.currency, _f = _b.currencyAsSymbol, currencyAsSymbol = _f === void 0 ? false : _f;
            var intlOptions = {
                minimumIntegerDigits: minimumIntegerDigits,
                minimumFractionDigits: minimumFractionDigits,
                maximumFractionDigits: maximumFractionDigits
            };
            intlOptions.style = NumberFormatStyle[style].toLowerCase();
            if (style == NumberFormatStyle.Currency) {
                intlOptions.currency = currency;
                intlOptions.currencyDisplay = currencyAsSymbol ? 'symbol' : 'code';
            }
            return new Intl.NumberFormat(locale, intlOptions).format(num);
        };
        return NumberFormatter;
    }());
    var DATE_FORMATS_SPLIT = /((?:[^yMLdHhmsaZEwGjJ']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|L+|d+|H+|h+|J+|j+|m+|s+|a|Z|G+|w+))(.*)/;
    var PATTERN_ALIASES = {
        yMMMdjms: datePartGetterFactory(combine([
            digitCondition('year', 1),
            nameCondition('month', 3),
            digitCondition('day', 1),
            digitCondition('hour', 1),
            digitCondition('minute', 1),
            digitCondition('second', 1),
        ])),
        yMdjm: datePartGetterFactory(combine([
            digitCondition('year', 1), digitCondition('month', 1), digitCondition('day', 1),
            digitCondition('hour', 1), digitCondition('minute', 1)
        ])),
        yMMMMEEEEd: datePartGetterFactory(combine([
            digitCondition('year', 1), nameCondition('month', 4), nameCondition('weekday', 4),
            digitCondition('day', 1)
        ])),
        yMMMMd: datePartGetterFactory(combine([digitCondition('year', 1), nameCondition('month', 4), digitCondition('day', 1)])),
        yMMMd: datePartGetterFactory(combine([digitCondition('year', 1), nameCondition('month', 3), digitCondition('day', 1)])),
        yMd: datePartGetterFactory(combine([digitCondition('year', 1), digitCondition('month', 1), digitCondition('day', 1)])),
        jms: datePartGetterFactory(combine([digitCondition('hour', 1), digitCondition('second', 1), digitCondition('minute', 1)])),
        jm: datePartGetterFactory(combine([digitCondition('hour', 1), digitCondition('minute', 1)]))
    };
    var DATE_FORMATS = {
        yyyy: datePartGetterFactory(digitCondition('year', 4)),
        yy: datePartGetterFactory(digitCondition('year', 2)),
        y: datePartGetterFactory(digitCondition('year', 1)),
        MMMM: datePartGetterFactory(nameCondition('month', 4)),
        MMM: datePartGetterFactory(nameCondition('month', 3)),
        MM: datePartGetterFactory(digitCondition('month', 2)),
        M: datePartGetterFactory(digitCondition('month', 1)),
        LLLL: datePartGetterFactory(nameCondition('month', 4)),
        dd: datePartGetterFactory(digitCondition('day', 2)),
        d: datePartGetterFactory(digitCondition('day', 1)),
        HH: hourExtracter(datePartGetterFactory(hour12Modify(digitCondition('hour', 2), false))),
        H: hourExtracter(datePartGetterFactory(hour12Modify(digitCondition('hour', 1), false))),
        hh: hourExtracter(datePartGetterFactory(hour12Modify(digitCondition('hour', 2), true))),
        h: hourExtracter(datePartGetterFactory(hour12Modify(digitCondition('hour', 1), true))),
        jj: datePartGetterFactory(digitCondition('hour', 2)),
        j: datePartGetterFactory(digitCondition('hour', 1)),
        mm: digitModifier(datePartGetterFactory(digitCondition('minute', 2))),
        m: datePartGetterFactory(digitCondition('minute', 1)),
        ss: digitModifier(datePartGetterFactory(digitCondition('second', 2))),
        s: datePartGetterFactory(digitCondition('second', 1)),
        // while ISO 8601 requires fractions to be prefixed with `.` or `,`
        // we can be just safely rely on using `sss` since we currently don't support single or two digit
        // fractions
        sss: datePartGetterFactory(digitCondition('second', 3)),
        EEEE: datePartGetterFactory(nameCondition('weekday', 4)),
        EEE: datePartGetterFactory(nameCondition('weekday', 3)),
        EE: datePartGetterFactory(nameCondition('weekday', 2)),
        E: datePartGetterFactory(nameCondition('weekday', 1)),
        a: hourClockExtracter(datePartGetterFactory(hour12Modify(digitCondition('hour', 1), true))),
        Z: datePartGetterFactory({ timeZoneName: 'long' }),
        z: datePartGetterFactory({ timeZoneName: 'short' }),
        ww: datePartGetterFactory({}),
        // first Thursday of the year. not support ?
        w: datePartGetterFactory({}),
        // of the year not support ?
        G: datePartGetterFactory(nameCondition('era', 1)),
        GG: datePartGetterFactory(nameCondition('era', 2)),
        GGG: datePartGetterFactory(nameCondition('era', 3)),
        GGGG: datePartGetterFactory(nameCondition('era', 4))
    };
    function digitModifier(inner) {
        return function (date, locale) {
            var result = inner(date, locale);
            return result.length == 1 ? '0' + result : result;
        };
    }
    function hourClockExtracter(inner) {
        return function (date, locale) {
            var result = inner(date, locale);
            return result.split(' ')[1];
        };
    }
    function hourExtracter(inner) {
        return function (date, locale) {
            var result = inner(date, locale);
            return result.split(' ')[0];
        };
    }
    function hour12Modify(options, value) {
        options.hour12 = value;
        return options;
    }
    function digitCondition(prop, len) {
        var result = {};
        result[prop] = len == 2 ? '2-digit' : 'numeric';
        return result;
    }
    function nameCondition(prop, len) {
        var result = {};
        result[prop] = len < 4 ? 'short' : 'long';
        return result;
    }
    function combine(options) {
        var result = {};
        options.forEach(function (option) { Object.assign(result, option); });
        return result;
    }
    function datePartGetterFactory(ret) {
        return function (date, locale) {
            return new Intl.DateTimeFormat(locale, ret).format(date);
        };
    }
    var datePartsFormatterCache = new Map();
    function dateFormatter(format, date, locale) {
        var text = '';
        var match;
        var fn;
        var parts = [];
        if (PATTERN_ALIASES[format]) {
            return PATTERN_ALIASES[format](date, locale);
        }
        if (datePartsFormatterCache.has(format)) {
            parts = datePartsFormatterCache.get(format);
        }
        else {
            var matchs = DATE_FORMATS_SPLIT.exec(format);
            while (format) {
                match = DATE_FORMATS_SPLIT.exec(format);
                if (match) {
                    parts = concat(parts, match, 1);
                    format = parts.pop();
                }
                else {
                    parts.push(format);
                    format = null;
                }
            }
            datePartsFormatterCache.set(format, parts);
        }
        parts.forEach(function (part) {
            fn = DATE_FORMATS[part];
            text += fn ? fn(date, locale) :
                part === '\'\'' ? '\'' : part.replace(/(^'|'$)/g, '').replace(/''/g, '\'');
        });
        return text;
    }
    var slice = [].slice;
    function concat(array1 /** TODO #9100 */, array2 /** TODO #9100 */, index /** TODO #9100 */) {
        return array1.concat(slice.call(array2, index));
    }
    var DateFormatter = (function () {
        function DateFormatter() {
        }
        DateFormatter.format = function (date, locale, pattern) {
            return dateFormatter(pattern, date, locale);
        };
        return DateFormatter;
    }());
    /**
     * @stable
     */
    var BaseException$1 = (function (_super) {
        __extends(BaseException$1, _super);
        function BaseException$1(message) {
            if (message === void 0) { message = '--'; }
            _super.call(this, message);
            this.message = message;
            this.stack = (new Error(message)).stack;
        }
        BaseException$1.prototype.toString = function () { return this.message; };
        return BaseException$1;
    }(Error));
    var InvalidPipeArgumentException = (function (_super) {
        __extends(InvalidPipeArgumentException, _super);
        function InvalidPipeArgumentException(type, value) {
            _super.call(this, "Invalid argument '" + value + "' for pipe '" + stringify$1(type) + "'");
        }
        return InvalidPipeArgumentException;
    }(BaseException$1));
    /**
     * LocaleNumber class.
     * Class to format numbers.
     */
    var LocaleNumber = (function () {
        function LocaleNumber() {
        }
        LocaleNumber.format = function (pipe, defaultLocale, value, style, digits, currency, currencyAsSymbol) {
            if (currency === void 0) { currency = null; }
            if (currencyAsSymbol === void 0) { currencyAsSymbol = false; }
            if (isBlank(value)) {
                return null;
            }
            if (!isNumber(value)) {
                throw new InvalidPipeArgumentException(pipe, value);
            }
            var minInt = 1;
            var minFraction = 0;
            var maxFraction = 3;
            var NUMBER_FORMAT_REGEXP = /^(\d+)?\.((\d+)(\-(\d+))?)?$/g;
            if (isPresent(digits)) {
                var parts = RegExpWrapper.firstMatch(NUMBER_FORMAT_REGEXP, digits);
                if (isBlank(parts)) {
                    throw new BaseException(digits + " is not a valid digit info for number pipes");
                }
                if (isPresent(parts[1])) {
                    minInt = NumberWrapper.parseIntAutoRadix(parts[1]);
                }
                if (isPresent(parts[3])) {
                    minFraction = NumberWrapper.parseIntAutoRadix(parts[3]);
                }
                if (isPresent(parts[5])) {
                    maxFraction = NumberWrapper.parseIntAutoRadix(parts[5]);
                }
            }
            return NumberFormatter.format(value, defaultLocale, style, {
                minimumIntegerDigits: minInt,
                minimumFractionDigits: minFraction,
                maximumFractionDigits: maxFraction,
                currency: currency,
                currencyAsSymbol: currencyAsSymbol
            });
        };
        return LocaleNumber;
    }());
    /**
     * LocaleParser class.
     * Parses a string and returns a number by default locale.
     *
     * @author Roberto Simonetti
     */
    var LocaleParser = (function () {
        function LocaleParser() {
        }
        /**
         * Builds the regular expression for a number by default locale.
         *
         * @param defaultLocale The default locale
         * @param digits The digit info: {minIntegerDigits}.{minFractionDigits}-{maxFractionDigits}
         * @return A RegExp object
         */
        LocaleParser.NumberRegExpFactory = function (defaultLocale, digits) {
            // Gets digits.
            var minInt = 1;
            var minFraction = 0;
            var maxFraction = 3;
            var NUMBER_FORMAT_REGEXP = /^(\d+)?\.((\d+)(\-(\d+))?)?$/g;
            if (isPresent(digits)) {
                var parts = RegExpWrapper.firstMatch(NUMBER_FORMAT_REGEXP, digits);
                if (isBlank(parts)) {
                    throw new BaseException(digits + " is not a valid digit info for number");
                }
                if (isPresent(parts[1])) {
                    minInt = NumberWrapper.parseIntAutoRadix(parts[1]);
                }
                if (isPresent(parts[3])) {
                    minFraction = NumberWrapper.parseIntAutoRadix(parts[3]);
                }
                if (isPresent(parts[5])) {
                    maxFraction = NumberWrapper.parseIntAutoRadix(parts[5]);
                }
            }
            // Converts numbers & signs to Unicode by default locale.
            var codes = new DecimalCode(defaultLocale);
            var minusSign = codes.minusSign;
            var zero = codes.numbers[0];
            var decimalSeparator = codes.decimalSeparator;
            var nine = codes.numbers[9];
            // Pattern for 1.2-2 digits: /^-?[0-9]{1,}\.[0-9]{2,2}$/
            // Unicode pattern = "^\u002d?[\u0030-\u0039]{1,}\\u002e[\u0030-\u0039]{2,2}$";
            var pattern;
            if (minFraction > 0 && maxFraction > 0) {
                pattern = "^"
                    + minusSign
                    + "?[" + zero + "-" + nine
                    + "]{" + minInt + ",}\\"
                    + decimalSeparator
                    + "[" + zero + "-" + nine
                    + "]{" + minFraction + "," + maxFraction
                    + "}$";
            }
            else if (minFraction == 0 && maxFraction > 0) {
                // Decimal separator is optional.
                pattern = "^"
                    + minusSign
                    + "?[" + zero + "-" + nine
                    + "]{" + minInt + ",}\\"
                    + decimalSeparator
                    + "?[" + zero + "-" + nine
                    + "]{" + minFraction + "," + maxFraction
                    + "}$";
            }
            else {
                // Integer number.
                pattern = "^"
                    + minusSign
                    + "?[" + zero + "-" + nine
                    + "]{" + minInt + ",}$";
            }
            pattern = codes.UnicodeToChar(pattern);
            var regExp = new RegExp(pattern);
            return regExp;
            // Wonderful, it works!
        };
        /**
         * Parses a string and returns a number by default locale.
         *
         * @param s The string to be parsed
         * @param defaultLocale The default locale
         * @return A number. If the string cannot be converted to a number, returns NaN
         */
        LocaleParser.Number = function (s, defaultLocale) {
            if (s == "" || defaultLocale == "" || defaultLocale == null) {
                return null;
            }
            var codes = new DecimalCode(defaultLocale);
            return codes.parse(s);
        };
        return LocaleParser;
    }());
    /**
     * NumberCode abstract superclass.
     *
     * Converts numbers to Unicode by locales.
     *
     * @author Roberto Simonetti
     */
    var NumberCode = (function () {
        function NumberCode(defaultLocale) {
            this.defaultLocale = defaultLocale;
            /**
             * Unicode for numbers from 0 to 9.
             */
            this.numbers = [];
            for (var i = 0; i <= 9; i++) {
                this.numbers.push(this.Unicode(i.toString()));
            }
            // Checks for support for Intl.
            if (IntlSupport.NumberFormat(defaultLocale) == true) {
                // Updates Unicode for numbers by default locale.
                for (var i = 0; i <= 9; i++) {
                    this.numbers[i] = this.Unicode(NumberFormatter.format(i, defaultLocale, NumberFormatStyle.Decimal, {
                        minimumIntegerDigits: 1,
                        minimumFractionDigits: 0,
                        maximumFractionDigits: 0,
                        currency: null,
                        currencyAsSymbol: false
                    }));
                }
            }
        }
        NumberCode.prototype.Unicode = function (c) {
            return "\\u" + this.HexEncode(c.charCodeAt(0));
        };
        NumberCode.prototype.HexEncode = function (value) {
            var hex = value.toString(16).toUpperCase();
            // With padding.
            hex = "0000".substr(0, 4 - hex.length) + hex;
            return hex;
        };
        return NumberCode;
    }());
    /**
     * DecimalCode class.
     *
     * Converts numbers & signs to Unicode by locales.
     *
     * @author Roberto Simonetti
     */
    var DecimalCode = (function (_super) {
        __extends(DecimalCode, _super);
        function DecimalCode(defaultLocale) {
            _super.call(this, defaultLocale);
            this.defaultLocale = defaultLocale;
            this.minusSign = this.Unicode("-");
            this.decimalSeparator = this.Unicode(".");
            // Checks for support for Intl.
            if (IntlSupport.NumberFormat(defaultLocale) == true) {
                // Updates Unicode for signs by default locale.
                var value = -0.9; // Reference value.
                var localeValue = NumberFormatter.format(value, defaultLocale, NumberFormatStyle.Decimal, {
                    minimumIntegerDigits: 1,
                    minimumFractionDigits: 1,
                    maximumFractionDigits: 1,
                    currency: null,
                    currencyAsSymbol: false
                });
                // Checks Unicode character 'RIGHT-TO-LEFT MARK' (U+200F).
                var index;
                if (this.Unicode(localeValue.charAt(0)) != "\\u200F") {
                    // Left to right.
                    index = 0;
                }
                else {
                    // Right to left.
                    index = 1;
                }
                this.minusSign = this.Unicode(localeValue.charAt(index));
                this.decimalSeparator = this.Unicode(localeValue.charAt(index + 2));
            }
        }
        DecimalCode.prototype.parse = function (s) {
            // Splits the String object into an array of characters.
            var characters = s.split("");
            // Builds the value.
            var value = "";
            for (var _i = 0, characters_1 = characters; _i < characters_1.length; _i++) {
                var char = characters_1[_i];
                var charCode = this.Unicode(char);
                // Tries to look for the char code in numbers and signs.
                var index = this.numbers.indexOf(charCode);
                if (index != -1) {
                    value += index;
                }
                else if (charCode == this.minusSign) {
                    value += "-";
                }
                else if (charCode == this.decimalSeparator) {
                    value += ".";
                }
                else {
                    return NaN;
                }
            }
            return parseFloat(value);
        };
        DecimalCode.prototype.UnicodeToChar = function (pattern) {
            return pattern.replace(/\\u[\dA-F]{4}/gi, function (match) {
                return String.fromCharCode(parseInt(match.replace(/\\u/g, ""), 16));
            });
        };
        return DecimalCode;
    }(NumberCode));
    /**
     * ANGULAR 2 LOCALIZATION
     * An Angular 2 library to translate messages, dates and numbers.
     * Written by Roberto Simonetti.
     * MIT license.
     * https://github.com/robisim74/angular2localization
     */
    var __decorate$2 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata$2 = (undefined && undefined.__metadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(k, v);
    };
    /**
     * 'translate' pipe function.
     */
    var TranslatePipe_1;
    exports.TranslatePipe = TranslatePipe_1 = (function () {
        function TranslatePipe(localization, locale) {
            this.localization = localization;
            this.locale = locale;
        }
        /**
         * TranslatePipe transform method.
         *
         * @param key The key to be translated
         * @param lang The current language code for the LocalizationService
         * @return The value of translation
         */
        TranslatePipe.prototype.transform = function (key, lang) {
            // Checks the service state.
            if (this.localization.serviceState == exports.ServiceState.isReady) {
                var REGEXP = /^\d+\b/;
                var keyStr = key;
                // i18n plural.
                if (REGEXP.exec(key) != null) {
                    // Tries to extract the number.
                    var keyNum = parseFloat(key);
                    // Tries to extract the string. 
                    keyStr = key.replace(REGEXP, "");
                    keyStr = keyStr.trim();
                    // Checks the number & support for Intl.
                    if (!isNaN(keyNum) && IntlSupport.NumberFormat(this.locale.getDefaultLocale()) == true) {
                        // Localizes the number.
                        key = key.replace(/^\d+/, LocaleNumber.format(TranslatePipe_1, this.locale.getDefaultLocale(), keyNum, NumberFormatStyle.Decimal, '1.0-3'));
                    }
                }
                // Gets the value of translation for the key string.
                var value = this.localization.translate(keyStr);
                return key.replace(keyStr, value);
            }
            return key;
        };
        return TranslatePipe;
    }());
    exports.TranslatePipe = TranslatePipe_1 = __decorate$2([
        _angular_core.Pipe({
            name: 'translate',
            pure: true
        }),
        __metadata$2('design:paramtypes', [exports.LocalizationService, exports.LocaleService])
    ], exports.TranslatePipe);
    var Map$2 = global$1.Map;
    var Set$1 = global$1.Set;
    // Safari and Internet Explorer do not support the iterable parameter to the
    // Map constructor.  We work around that by manually adding the items.
    var createMapFromPairs$1 = (function () {
        try {
            if (new Map$2([[1, 2]]).size === 1) {
                return function createMapFromPairs(pairs) { return new Map$2(pairs); };
            }
        }
        catch (e) {
        }
        return function createMapAndPopulateFromPairs(pairs) {
            var map = new Map$2();
            for (var i = 0; i < pairs.length; i++) {
                var pair = pairs[i];
                map.set(pair[0], pair[1]);
            }
            return map;
        };
    })();
    var createMapFromMap$1 = (function () {
        try {
            if (new Map$2(new Map$2())) {
                return function createMapFromMap(m) { return new Map$2(m); };
            }
        }
        catch (e) {
        }
        return function createMapAndPopulateFromMap(m) {
            var map = new Map$2();
            m.forEach(function (v, k) { map.set(k, v); });
            return map;
        };
    })();
    var _clearValues$1 = (function () {
        if ((new Map$2()).keys().next) {
            return function _clearValues(m) {
                var keyIterator = m.keys();
                var k;
                while (!((k = keyIterator.next()).done)) {
                    m.set(k.value, null);
                }
            };
        }
        else {
            return function _clearValuesWithForeEach(m) {
                m.forEach(function (v, k) { m.set(k, null); });
            };
        }
    })();
    // Safari doesn't implement MapIterator.next(), which is used is Traceur's polyfill of Array.from
    // TODO(mlaval): remove the work around once we have a working polyfill of Array.from
    var _arrayFromMap$1 = (function () {
        try {
            if ((new Map$2()).values().next) {
                return function createArrayFromMap(m, getValues) {
                    return getValues ? Array.from(m.values()) : Array.from(m.keys());
                };
            }
        }
        catch (e) {
        }
        return function createArrayFromMapWithForeach(m, getValues) {
            var res = ListWrapper$1.createFixedSize(m.size), i = 0;
            m.forEach(function (v, k) {
                res[i] = getValues ? v : k;
                i++;
            });
            return res;
        };
    })();
    /**
     * Wraps Javascript Objects
     */
    var StringMapWrapper$1 = (function () {
        function StringMapWrapper$1() {
        }
        StringMapWrapper$1.create = function () {
            // Note: We are not using Object.create(null) here due to
            // performance!
            // http://jsperf.com/ng2-object-create-null
            return {};
        };
        StringMapWrapper$1.contains = function (map, key) {
            return map.hasOwnProperty(key);
        };
        StringMapWrapper$1.get = function (map, key) {
            return map.hasOwnProperty(key) ? map[key] : undefined;
        };
        StringMapWrapper$1.set = function (map, key, value) { map[key] = value; };
        StringMapWrapper$1.keys = function (map) { return Object.keys(map); };
        StringMapWrapper$1.values = function (map) {
            return Object.keys(map).reduce(function (r, a) {
                r.push(map[a]);
                return r;
            }, []);
        };
        StringMapWrapper$1.isEmpty = function (map) {
            for (var prop in map) {
                return false;
            }
            return true;
        };
        StringMapWrapper$1.delete = function (map, key) { delete map[key]; };
        StringMapWrapper$1.forEach = function (map, callback) {
            for (var prop in map) {
                if (map.hasOwnProperty(prop)) {
                    callback(map[prop], prop);
                }
            }
        };
        StringMapWrapper$1.merge = function (m1, m2) {
            var m = {};
            for (var attr in m1) {
                if (m1.hasOwnProperty(attr)) {
                    m[attr] = m1[attr];
                }
            }
            for (var attr in m2) {
                if (m2.hasOwnProperty(attr)) {
                    m[attr] = m2[attr];
                }
            }
            return m;
        };
        StringMapWrapper$1.equals = function (m1, m2) {
            var k1 = Object.keys(m1);
            var k2 = Object.keys(m2);
            if (k1.length != k2.length) {
                return false;
            }
            var key;
            for (var i = 0; i < k1.length; i++) {
                key = k1[i];
                if (m1[key] !== m2[key]) {
                    return false;
                }
            }
            return true;
        };
        return StringMapWrapper$1;
    }());
    var ListWrapper$1 = (function () {
        function ListWrapper$1() {
        }
        // JS has no way to express a statically fixed size list, but dart does so we
        // keep both methods.
        ListWrapper$1.createFixedSize = function (size) { return new Array(size); };
        ListWrapper$1.createGrowableSize = function (size) { return new Array(size); };
        ListWrapper$1.clone = function (array) { return array.slice(0); };
        ListWrapper$1.forEachWithIndex = function (array, fn) {
            for (var i = 0; i < array.length; i++) {
                fn(array[i], i);
            }
        };
        ListWrapper$1.first = function (array) {
            if (!array)
                return null;
            return array[0];
        };
        ListWrapper$1.last = function (array) {
            if (!array || array.length == 0)
                return null;
            return array[array.length - 1];
        };
        ListWrapper$1.indexOf = function (array, value, startIndex) {
            if (startIndex === void 0) { startIndex = 0; }
            return array.indexOf(value, startIndex);
        };
        ListWrapper$1.contains = function (list, el) { return list.indexOf(el) !== -1; };
        ListWrapper$1.reversed = function (array) {
            var a = ListWrapper$1.clone(array);
            return a.reverse();
        };
        ListWrapper$1.concat = function (a, b) { return a.concat(b); };
        ListWrapper$1.insert = function (list, index, value) { list.splice(index, 0, value); };
        ListWrapper$1.removeAt = function (list, index) {
            var res = list[index];
            list.splice(index, 1);
            return res;
        };
        ListWrapper$1.removeAll = function (list, items) {
            for (var i = 0; i < items.length; ++i) {
                var index = list.indexOf(items[i]);
                list.splice(index, 1);
            }
        };
        ListWrapper$1.remove = function (list, el) {
            var index = list.indexOf(el);
            if (index > -1) {
                list.splice(index, 1);
                return true;
            }
            return false;
        };
        ListWrapper$1.clear = function (list) { list.length = 0; };
        ListWrapper$1.isEmpty = function (list) { return list.length == 0; };
        ListWrapper$1.fill = function (list, value, start, end) {
            if (start === void 0) { start = 0; }
            if (end === void 0) { end = null; }
            list.fill(value, start, end === null ? list.length : end);
        };
        ListWrapper$1.equals = function (a, b) {
            if (a.length != b.length)
                return false;
            for (var i = 0; i < a.length; ++i) {
                if (a[i] !== b[i])
                    return false;
            }
            return true;
        };
        ListWrapper$1.slice = function (l, from, to) {
            if (from === void 0) { from = 0; }
            if (to === void 0) { to = null; }
            return l.slice(from, to === null ? undefined : to);
        };
        ListWrapper$1.splice = function (l, from, length) { return l.splice(from, length); };
        ListWrapper$1.sort = function (l, compareFn) {
            if (isPresent$1(compareFn)) {
                l.sort(compareFn);
            }
            else {
                l.sort();
            }
        };
        ListWrapper$1.toString = function (l) { return l.toString(); };
        ListWrapper$1.toJSON = function (l) { return JSON.stringify(l); };
        ListWrapper$1.maximum = function (list, predicate) {
            if (list.length == 0) {
                return null;
            }
            var solution = null;
            var maxValue = -Infinity;
            for (var index = 0; index < list.length; index++) {
                var candidate = list[index];
                if (isBlank$1(candidate)) {
                    continue;
                }
                var candidateValue = predicate(candidate);
                if (candidateValue > maxValue) {
                    solution = candidate;
                    maxValue = candidateValue;
                }
            }
            return solution;
        };
        ListWrapper$1.flatten = function (list) {
            var target = [];
            _flattenArray$1(list, target);
            return target;
        };
        ListWrapper$1.addAll = function (list, source) {
            for (var i = 0; i < source.length; i++) {
                list.push(source[i]);
            }
        };
        return ListWrapper$1;
    }());
    function _flattenArray$1(source, target) {
        if (isPresent$1(source)) {
            for (var i = 0; i < source.length; i++) {
                var item = source[i];
                if (isArray$2(item)) {
                    _flattenArray$1(item, target);
                }
                else {
                    target.push(item);
                }
            }
        }
        return target;
    }
    // Safari and Internet Explorer do not support the iterable parameter to the
    // Set constructor.  We work around that by manually adding the items.
    var createSetFromList$1 = (function () {
        var test = new Set$1([1, 2, 3]);
        if (test.size === 3) {
            return function createSetFromList(lst) { return new Set$1(lst); };
        }
        else {
            return function createSetAndPopulateFromList(lst) {
                var res = new Set$1(lst);
                if (res.size !== lst.length) {
                    for (var i = 0; i < lst.length; i++) {
                        res.add(lst[i]);
                    }
                }
                return res;
            };
        }
    })();
    /**
     * ANGULAR 2 LOCALIZATION
     * An Angular 2 library to translate messages, dates and numbers.
     * Written by Roberto Simonetti.
     * MIT license.
     * https://github.com/robisim74/angular2localization
     */
    var __decorate$3 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata$3 = (undefined && undefined.__metadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(k, v);
    };
    /**
     * 'localedate' pipe function.
     */
    var LocaleDatePipe_1;
    exports.LocaleDatePipe = LocaleDatePipe_1 = (function () {
        function LocaleDatePipe() {
        }
        /**
         * LocaleDatePipe transform method.
         *
         * @param value The date to be localized
         * @param defaultLocale The default locale
         * @param pattern The format of the date
         * @return The locale date
         */
        LocaleDatePipe.prototype.transform = function (value, defaultLocale, pattern) {
            if (pattern === void 0) { pattern = 'mediumDate'; }
            if (isBlank(value)) {
                return null;
            }
            if (!this.supports(value)) {
                throw new InvalidPipeArgumentException(LocaleDatePipe_1, value);
            }
            if (NumberWrapper.isNumeric(value)) {
                value = DateWrapper.fromMillis(NumberWrapper.parseInt(value, 10));
            }
            else if (isString(value)) {
                value = DateWrapper.fromISOString(value);
            }
            // Checks for support for Intl.
            if (IntlSupport.DateTimeFormat(defaultLocale) == true) {
                if (StringMapWrapper$1.contains(LocaleDatePipe_1.ALIASES, pattern)) {
                    pattern = StringMapWrapper$1.get(LocaleDatePipe_1.ALIASES, pattern);
                }
                return DateFormatter.format(value, defaultLocale, pattern);
            }
            // Returns the date without localization.
            return value;
        };
        LocaleDatePipe.prototype.supports = function (obj) {
            if (isDate(obj) || NumberWrapper.isNumeric(obj)) {
                return true;
            }
            if (isString(obj) && isDate(DateWrapper.fromISOString(obj))) {
                return true;
            }
            return false;
        };
        return LocaleDatePipe;
    }());
    exports.LocaleDatePipe.ALIASES = {
        'medium': 'yMMMdjms',
        'short': 'yMdjm',
        'fullDate': 'yMMMMEEEEd',
        'longDate': 'yMMMMd',
        'mediumDate': 'yMMMd',
        'shortDate': 'yMd',
        'mediumTime': 'jms',
        'shortTime': 'jm'
    };
    exports.LocaleDatePipe = LocaleDatePipe_1 = __decorate$3([
        _angular_core.Pipe({
            name: 'localedate',
            pure: true
        }),
        __metadata$3('design:paramtypes', [])
    ], exports.LocaleDatePipe);
    /**
     * ANGULAR 2 LOCALIZATION
     * An Angular 2 library to translate messages, dates and numbers.
     * Written by Roberto Simonetti.
     * MIT license.
     * https://github.com/robisim74/angular2localization
     */
    var __decorate$4 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata$4 = (undefined && undefined.__metadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(k, v);
    };
    /**
     * 'localedecimal' pipe function.
     */
    var LocaleDecimalPipe_1;
    exports.LocaleDecimalPipe = LocaleDecimalPipe_1 = (function () {
        function LocaleDecimalPipe() {
        }
        /**
         * LocaleDecimalPipe transform method.
         *
         * @param value The number to be localized
         * @param defaultLocale The default locale
         * @param digits The format of the number
         * @return The locale decimal
         */
        LocaleDecimalPipe.prototype.transform = function (value, defaultLocale, digits) {
            if (digits === void 0) { digits = null; }
            // Checks for support for Intl.
            if (IntlSupport.NumberFormat(defaultLocale) == true) {
                return LocaleNumber.format(LocaleDecimalPipe_1, defaultLocale, value, NumberFormatStyle.Decimal, digits);
            }
            // Returns the number without localization.
            return value;
        };
        return LocaleDecimalPipe;
    }());
    exports.LocaleDecimalPipe = LocaleDecimalPipe_1 = __decorate$4([
        _angular_core.Pipe({
            name: 'localedecimal',
            pure: true
        }),
        __metadata$4('design:paramtypes', [])
    ], exports.LocaleDecimalPipe);
    /**
     * 'localepercent' pipe function.
     */
    var LocalePercentPipe_1;
    exports.LocalePercentPipe = LocalePercentPipe_1 = (function () {
        function LocalePercentPipe() {
        }
        /**
         * LocalePercentPipe transform method.
         *
         * @param value The number to be localized
         * @param defaultLocale The default locale
         * @param digits The format of the number
         * @return The locale percent
         */
        LocalePercentPipe.prototype.transform = function (value, defaultLocale, digits) {
            if (digits === void 0) { digits = null; }
            // Checks for support for Intl.
            if (IntlSupport.NumberFormat(defaultLocale) == true) {
                return LocaleNumber.format(LocalePercentPipe_1, defaultLocale, value, NumberFormatStyle.Percent, digits);
            }
            // Returns the number without localization.
            return value;
        };
        return LocalePercentPipe;
    }());
    exports.LocalePercentPipe = LocalePercentPipe_1 = __decorate$4([
        _angular_core.Pipe({
            name: 'localepercent',
            pure: true
        }),
        __metadata$4('design:paramtypes', [])
    ], exports.LocalePercentPipe);
    /**
     * 'localecurrency' pipe function.
     */
    var LocaleCurrencyPipe_1;
    exports.LocaleCurrencyPipe = LocaleCurrencyPipe_1 = (function () {
        function LocaleCurrencyPipe() {
        }
        /**
         * LocaleCurrencyPipe transform method.
         *
         * @param value The number to be localized
         * @param defaultLocale The default locale
         * @param currency The current currency
         * @param symbolDisplay Indicates whether to use the currency symbol
         * @param digits The format of the number
         * @return The locale currency
         */
        LocaleCurrencyPipe.prototype.transform = function (value, defaultLocale, currency, symbolDisplay, digits) {
            if (symbolDisplay === void 0) { symbolDisplay = false; }
            if (digits === void 0) { digits = null; }
            // Checks for support for Intl.
            if (IntlSupport.NumberFormat(defaultLocale) == true) {
                return LocaleNumber.format(LocaleCurrencyPipe_1, defaultLocale, value, NumberFormatStyle.Currency, digits, currency, symbolDisplay);
            }
            // Returns the number without localization & currency.
            return value + " " + currency;
        };
        return LocaleCurrencyPipe;
    }());
    exports.LocaleCurrencyPipe = LocaleCurrencyPipe_1 = __decorate$4([
        _angular_core.Pipe({
            name: 'localecurrency',
            pure: true
        }),
        __metadata$4('design:paramtypes', [])
    ], exports.LocaleCurrencyPipe);
    /**
     * ANGULAR 2 LOCALIZATION
     * An Angular 2 library to translate messages, dates and numbers.
     * Written by Roberto Simonetti.
     * MIT license.
     * https://github.com/robisim74/angular2localization
     */
    var __decorate$5 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __metadata$5 = (undefined && undefined.__metadata) || function (k, v) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(k, v);
    };
    /**
     * Function that takes a Control and returns either null when its valid, or and error object if its not.
     *
     * @param locale The reference to LocaleService
     * @param digits The format of the number
     * @param MIN_VALUE The minimum value for the number
     * @param MAX_VALUE The maximum value for the number
     * @return An error object: 'format', 'minValue' or 'maxValue'; null in case the value is valid
     */
    function validateLocaleNumber(locale, digits, MIN_VALUE, MAX_VALUE) {
        if (MIN_VALUE === void 0) { MIN_VALUE = Number.MIN_VALUE; }
        if (MAX_VALUE === void 0) { MAX_VALUE = Number.MAX_VALUE; }
        var defaultLocale;
        var NUMBER_REGEXP;
        return function (c) {
            // Checks if the default locale has changed. 
            if (defaultLocale != locale.getDefaultLocale()) {
                NUMBER_REGEXP = LocaleParser.NumberRegExpFactory(locale.getDefaultLocale(), digits);
                defaultLocale = locale.getDefaultLocale();
            }
            // Checks the format.
            if (NUMBER_REGEXP.test(c.value)) {
                var parsedValue;
                parsedValue = LocaleParser.Number(c.value, locale.getDefaultLocale());
                if (parsedValue < MIN_VALUE) {
                    return { minValue: false };
                }
                else if (parsedValue > MAX_VALUE) {
                    return { maxValue: false };
                }
                return null; // The number is valid.
            }
            else {
                return { format: false };
            }
        };
    }
    var LocaleNumberValidator_1;
    exports.LocaleNumberValidator = LocaleNumberValidator_1 = (function () {
        function LocaleNumberValidator(locale) {
            this.locale = locale;
            this.MIN_VALUE = Number.MIN_VALUE;
            this.MAX_VALUE = Number.MAX_VALUE;
        }
        Object.defineProperty(LocaleNumberValidator.prototype, "minValue", {
            set: function (value) {
                this.MIN_VALUE = value || this.MIN_VALUE;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LocaleNumberValidator.prototype, "maxValue", {
            set: function (value) {
                this.MAX_VALUE = value || this.MAX_VALUE;
            },
            enumerable: true,
            configurable: true
        });
        LocaleNumberValidator.prototype.ngOnInit = function () {
            this.validator = validateLocaleNumber(this.locale, this.digits, this.MIN_VALUE, this.MAX_VALUE);
        };
        LocaleNumberValidator.prototype.validate = function (c) {
            return this.validator(c);
        };
        return LocaleNumberValidator;
    }());
    __decorate$5([
        _angular_core.Input('validateLocaleNumber'),
        __metadata$5('design:type', String)
    ], exports.LocaleNumberValidator.prototype, "digits", void 0);
    __decorate$5([
        _angular_core.Input(),
        __metadata$5('design:type', Number),
        __metadata$5('design:paramtypes', [Number])
    ], exports.LocaleNumberValidator.prototype, "minValue", null);
    __decorate$5([
        _angular_core.Input(),
        __metadata$5('design:type', Number),
        __metadata$5('design:paramtypes', [Number])
    ], exports.LocaleNumberValidator.prototype, "maxValue", null);
    exports.LocaleNumberValidator = LocaleNumberValidator_1 = __decorate$5([
        _angular_core.Directive({
            selector: '[validateLocaleNumber][ngModel],[validateLocaleNumber][formControl]',
            providers: [
                _angular_core.provide(_angular_forms.NG_VALIDATORS, {
                    useExisting: _angular_core.forwardRef(function () { return exports.LocaleNumberValidator; }),
                    multi: true
                })
            ]
        }),
        __metadata$5('design:paramtypes', [exports.LocaleService])
    ], exports.LocaleNumberValidator);
    exports.Locale = Locale;
    exports.LocaleNumber = LocaleNumber;
    exports.IntlSupport = IntlSupport;
    exports.LocaleParser = LocaleParser;
    exports.validateLocaleNumber = validateLocaleNumber;
    Object.defineProperty(exports, '__esModule', { value: true });
}));
